; Zilog eZ80 ANSI C Compiler Release 3.4
; -debug -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\MAIN.C"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",9
.DEFINE "sign"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "mant"
.VALUE 2
.CLASS 8
.DIM 7
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",18
.DEFINE "real"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.DEFINE "imag"
.VALUE 9
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",11
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",20
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME1"
.TYPE 104
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",11
.DEFINE "cols"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rows"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",3
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME7"
.BEGREC "font",12
.DEFINE "font"
.VALUE 0
.CLASS 8
.TAG "font"
.TYPE 40
.ENDEF
.DEFINE "drawChar"
.VALUE 3
.CLASS 8
.TYPE 545
.ENDEF
.DEFINE "getWidth"
.VALUE 6
.CLASS 8
.TYPE 558
.ENDEF
.DEFINE "getHeight"
.VALUE 9
.CLASS 8
.TYPE 558
.ENDEF
.ENDREC "font"
.BEGREC "system_info",40
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "hardwareVersion"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "hardwareType"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "hardwareType2"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "osMajorVersion"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "osMinorVersion"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "osRevisionVersion"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "osBuildVersion"
.VALUE 9
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "bootMajorVersion"
.VALUE 12
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "bootMinorVersion"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "bootRevisionVersion"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "bootBuildVersion"
.VALUE 15
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "unknown"
.VALUE 18
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.DEFINE "calcid"
.VALUE 28
.CLASS 8
.DIM 8
.TYPE 108
.ENDEF
.DEFINE "ti"
.VALUE 36
.CLASS 8
.DIM 2
.TYPE 98
.ENDEF
.DEFINE "language"
.VALUE 38
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "system_info"
.BEGREC "NONAME8",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME9"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME10"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME10",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME10"
.BEGREC "NONAME11",3
.DEFINE "width"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "height"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME11"
.BEGREC "NONAME12",3
.DEFINE "width"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "height"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME12"
.BEGREC "NONAME13",6
.DEFINE "x"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "y"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME13"
.BEGREC "NONAME14",12
.DEFINE "xmin"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "ymin"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "xmax"
.VALUE 6
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "ymax"
.VALUE 9
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME14"
.BEGREC "NONAME15",18
.DEFINE "map"
.VALUE 0
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "tiles"
.VALUE 3
.CLASS 8
.TAG "NONAME11"
.TYPE 296
.ENDEF
.DEFINE "tile_height"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "tile_width"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "draw_height"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "draw_width"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "type_width"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "type_height"
.VALUE 11
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "height"
.VALUE 12
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "width"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "y_loc"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "x_loc"
.VALUE 15
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME15"
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "__stdio_file",1
.DEFINE "slot"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "__stdio_file"
;    1	#include <tice.h>
;    2	#include <graphx.h>
;    3	#include <keypadc.h>
;    4	#include <stdbool.h>
;    5	#include <stddef.h>
;    6	#include <stdint.h>
;    7	#include <stdio.h>
;    8	#include <stdlib.h>
;    9	#include <string.h>
;   10	#include <fileioc.h>
;   11	#include <debug.h>
;   12	#include <math.h>
;   13	
;   14	/* globals */
;   15	
;   16	#define BYTES_PER_IMAGE_NAME 9 //8 for image name, 1 for null terminator
;   17	#define MAX_IMAGES 936 //Max images is this because max combinations of appvars goes up to that
;   18	#define TASKS_TO_FINISH 2
;   19	#define X_MARGIN 8
;   20	#define Y_MARGIN 38
;   21	#define Y_SPACING 25
;   22	#define MAX_THUMBNAIL_WIDTH 160
;   23	#define MAX_THUMBNAIL_HEIGHT 240
;   24	#define THUMBNAIL_ZOOM 0
;   25	#define SQUARE_WIDTH_AND_HEIGHT 80
;   26	
;   27	
;   28	
;   29	
;   30	
;   31	/* Function Prototyptes */
;   32	uint8_t databaseReady();
;   33	void DisplayHomeScreen(uint24_t pics);
;   34	void DrawImage(uint24_t picName, uint24_t maxWidth, uint24_t maxHeight);
;   35	void noImagesFound();
;   36	void PrintCentered(const char *str);
;   37	void PrintCenteredX(const char *str, uint8_t y);
;   38	void PrintCenteredY(const char *str, uint8_t x);
;   39	void printNames(uint24_t start, char *picNames, uint24_t numOfPics);
;   40	void printText(int8_t xpos, int8_t ypos, const char *text);
;   41	uint24_t rebuildDB(uint8_t p);
;   42	void SplashScreen();
;   43	void SetLoadingBarProgress(uint8_t p, uint8_t t);
;   44	
;   45	/* Main function, called first */
;   46	int main(void)
;   47	{
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",47,"_main"

.LINE 47

.DEFINE "ready"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "picsDetected"

.CLASS 65

.VALUE -4

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   48	  uint8_t ready=0, tasksFinished = 0;
.LINE 48

	LD	(IX+-1),0
;   49	  uint24_t picsDetected=0;
.LINE 49

	LD	BC,0
	LD	(IX+-4),BC
;   50	  /* Clear the homescreen */
;   51	  //os_ClrHome();
;   52	
;   53	  gfx_Begin();
.LINE 53

	CALL	_gfx_Begin
;   54	  ti_CloseAll();
.LINE 54

	CALL	_ti_CloseAll
;   55	  SplashScreen();
.LINE 55

	CALL	_SplashScreen
;   56	  SetLoadingBarProgress(++tasksFinished, TASKS_TO_FINISH);
.LINE 56

	LD	BC,2
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_SetLoadingBarProgress
	POP	BC
	POP	BC
;   57	  //checks if the database exists and is ready 0 failure; 1 created; 2 exists
;   58	  ready = databaseReady();
.LINE 58

	CALL	_databaseReady
	LD	(IX+-1),A
;   59	  if (ready==0)
.LINE 59

	OR	A,A
	JR	Z,L_6
;   60	  goto err;
;   61	
;   62	
;   63	  picsDetected=rebuildDB(tasksFinished);
.LINE 63

	LD	BC,1
	PUSH	BC
	CALL	_rebuildDB
	POP	BC
	LD	(IX+-4),HL
;   64	  if(picsDetected==0)
.LINE 64

	CALL	__icmpzero
	JR	Z,L_6
;   65	  goto err;
;   66	  //returns how many images were found. 0 means quit.
;   67	
;   68	  SetLoadingBarProgress(++tasksFinished,TASKS_TO_FINISH);
.LINE 68

	LD	BC,2
	PUSH	BC
	PUSH	BC
	CALL	_SetLoadingBarProgress
	POP	BC
	POP	BC
;   69	  DisplayHomeScreen(picsDetected);
.LINE 69

	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_DisplayHomeScreen
	POP	BC
;   70	
;   71	  err:
;   72	  /* Waits for a keypress */
;   73	  while (!os_GetCSC());
L_6:
.LINE 73

	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_6
;   74	  ti_CloseAll();
.LINE 74

	CALL	_ti_CloseAll
;   75	  gfx_End();
.LINE 75

	CALL	_gfx_End
;   76	
;   77	  /* Return 0 for success */
;   78	  return 0;
.LINE 78

	OR	A,A
	SBC	HL,HL
;   79	
;   80	}
.LINE 80

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_gfx_End                            IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_DisplayHomeScreen                  IMPORT  -----   function
;_rebuildDB                          IMPORT  -----   function
;_databaseReady                      IMPORT  -----   function
;_SetLoadingBarProgress              IMPORT  -----   function
;_SplashScreen                       IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;picsDetected                          IX-4      3   variable
;ready                                 IX-1      1   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "main",80,"_main"
;   81	
;   82	/* Functions */
;   83	
;   84	void DisplayHomeScreen(uint24_t pics){
_DisplayHomeScreen:
.DEFINE "_DisplayHomeScreen"

.VALUE _DisplayHomeScreen

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "DisplayHomeScreen",84,"_DisplayHomeScreen"

.LINE 84

.DEFINE "pics"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

.DEFINE "startName"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "picNames"

.CLASS 65

.VALUE -9

.TYPE 34

.ENDEF

.DEFINE "database"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

.DEFINE "key"

.CLASS 65

.VALUE -11

.TYPE 12

.ENDEF

.DEFINE "Ypos"

.CLASS 65

.VALUE -18

.TYPE 12

.ENDEF

.DEFINE "up"

.CLASS 65

.VALUE -22

.TYPE 12

.ENDEF

.DEFINE "down"

.CLASS 65

.VALUE -23

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-35
	LD	SP,HL
;   85	  char *picNames = malloc(pics*BYTES_PER_IMAGE_NAME); //BYTES_PER_IMAGE_NAME = 9
.LINE 85

	LD	HL,(IX+6)
	LD	A,9
	CALL	__imul_b
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+-9),HL
;   86	  ti_var_t database = ti_Open("HDPICDB","r");
.LINE 86

	LD	BC,L__4
	PUSH	BC
	LD	BC,L__5
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-10),A
;   87	  uint24_t i,startName=0;
.LINE 87

	LD	BC,0
	LD	(IX+-3),BC
;   88	  uint8_t Ypos=10;
.LINE 88

	LD	(IX+-18),10
;   89	  kb_key_t key = kb_Data[7];
;   90	  bool up,down,left,right;
;   91	
;   92	
;   93	  //makes the screen black and sets text white
;   94	  gfx_FillScreen(0);
.LINE 94

	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;   95	  gfx_SetTextFGColor(254);
.LINE 95

	LD	BC,254
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;   96	  gfx_SetTextBGColor(0);
.LINE 96

	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTextBGColor
	POP	BC
;   97	  gfx_SetColor(255);
.LINE 97

	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;   98	  gfx_VertLine(140,20,200);
.LINE 98

	LD	BC,200
	PUSH	BC
	LD	BC,20
	PUSH	BC
	LD	BC,140
	PUSH	BC
	CALL	_gfx_VertLine
	POP	BC
	POP	BC
	POP	BC
;   99	
;  100	
;  101	  //seeks to the first image name
;  102	  ti_Seek(8,SEEK_SET,database);
.LINE 102

	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,8
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  103	  //PrintCenteredX("Test1",30);
;  104	  //loops through every picture that was detected and store the image name to picNames
;  105	  for(i=0;i<=pics;i++){
.LINE 105

	LD	BC,0
	LD	(IX+-6),BC
	JR	L_12
L_10:
;  106	    ti_Read(&picNames[i * BYTES_PER_IMAGE_NAME],8,1,database);
.LINE 106

	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	HL,(IX+-6)
	LD	A,9
	CALL	__imul_b
	LD	BC,(IX+-9)
	ADD	HL,BC
	PUSH	HL
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  107	    picNames[i * BYTES_PER_IMAGE_NAME + BYTES_PER_IMAGE_NAME - 1] = 0;
.LINE 107

	LD	HL,(IX+-6)
	LD	A,9
	CALL	__imul_b
	LD	IY,HL
	LEA	BC,IY+9
	DEC	BC
	LD	HL,(IX+-9)
	ADD	HL,BC
	LD	(HL),0
;  108	    ti_Seek(8,SEEK_CUR,database);
.LINE 108

	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  109	    //PrintCenteredX("Test2",40);
;  110	    Ypos+=15;
.LINE 110

	LD	A,(IX+-18)
	ADD	A,15
	LD	(IX+-18),A
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
;  111	    //PrintCenteredX(&picNames[i*BYTES_PER_IMAGE_NAME],Ypos);
;  112	
;  113	  }
L_12:
.LINE 113

	LD	BC,(IX+-6)
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_10
;  114	
;  115	  /* Keypress handler */
;  116	  gfx_SetTextXY(10,10);
.LINE 116

	LD	BC,10
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  117	  printNames(startName, picNames, pics);
.LINE 117

	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_printNames
	POP	BC
	POP	BC
	POP	BC
;  118	  DrawImage(startName,320,240);
.LINE 118

	LD	BC,240
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_DrawImage
	POP	BC
	POP	BC
	POP	BC
;  119	  do{
L_33:
.LINE 119

;  120	    //scans the keys for keypress
;  121	    kb_Scan();
.LINE 121

	CALL	_kb_Scan
;  122	    //checks if up or down arrow key were pressed
;  123	    key = kb_Data[7];
.LINE 123

	LD	A,(16056350)
	LD	(IX+-11),A
;  124	    down= key & kb_Down;
.LINE 124

	AND	A,1
	LD	(IX+-23),A
;  125	    up  = key & kb_Up;
.LINE 125

	LD	A,(IX+-11)
	AND	A,8
	LD	(IX+-22),A
;  126	    //if any key was pressed
;  127	    if(key){
.LINE 127

	LD	A,(IX+-11)
	OR	A,A
	JR	Z,L_34
;  128	      /* increases the name to start on and redraws the text */
;  129	      if(down){
.LINE 129

	LD	A,(IX+-23)
	OR	A,A
	JR	Z,L_31
;  130	        //PrintCenteredX("DOWN",10);
;  131	        startName++;
.LINE 131

	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  132	        //make sure user can't scroll down too far
;  133	        if (startName>(pics-1))//If there's more than 4 images, then handle things normally
.LINE 133

	LD	IY,(IX+6)
	LEA	IY,IY+-1
	LD	(IX+-17),IY
	LD	(IX+-26),IY
	LD	BC,(IX+-3)
	LD	HL,(IX+-17)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_18
;  134	        startName=pics-1;
.LINE 134

	LD	BC,(IX+-17)
	LD	(IX+-26),BC
	LD	BC,(IX+-17)
	LD	(IX+-3),BC
L_18:
;  135	        if (startName>pics-1 && pics-1>0) //makes sure user can't scroll too far when there's only 1 image detected
.LINE 135

	LD	BC,(IX+-26)
	LD	(IX+-21),BC
	LD	(IX+-32),BC
	LD	BC,(IX+-3)
	LD	HL,(IX+-21)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_21
	LD	BC,(IX+-21)
	LD	(IX+-32),BC
	LD	BC,(IX+-21)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_21
;  136	        startName=pics;
.LINE 136

	LD	BC,(IX+6)
	LD	(IX+-3),BC
L_21:
;  137	        if (startName>pics-2 && pics-2>0) //makes sure user can't scroll too far when there's only 2 images detected
.LINE 137

	LD	IY,(IX+6)
	LEA	IY,IY+-2
	LD	(IX+-14),IY
	LD	(IX+-29),IY
	LD	BC,(IX+-3)
	LD	HL,(IX+-14)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_24
	LD	BC,(IX+-14)
	LD	(IX+-29),BC
	LD	BC,(IX+-14)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_24
;  138	        startName=pics-1;
.LINE 138

	LD	BC,(IX+-32)
	LD	(IX+-3),BC
L_24:
;  139	        if (startName>pics-3 && pics-3>0) //makes sure user can't scroll too far when there's only 3 images detected
.LINE 139

	LD	IY,(IX+6)
	LEA	IY,IY+-3
	LD	(IX+-35),IY
	LD	BC,(IX+-3)
	LD	HL,(IX+-35)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_25
	LD	BC,(IX+-35)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_25
;  140	        startName=pics-2;
.LINE 140

	LD	BC,(IX+-29)
	LD	(IX+-3),BC
L_25:
;  141	        printNames(startName, picNames, pics);
.LINE 141

	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_printNames
	POP	BC
	POP	BC
	POP	BC
;  142	        DrawImage(startName,320,240);
.LINE 142

	LD	BC,240
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_DrawImage
	POP	BC
	POP	BC
	POP	BC
;  143	      }
L_31:
.LINE 143

;  144	      //key = kb_Data[3];
;  145	
;  146	      /* decreases the name to start on and redraws the text */
;  147	      if(up){
.LINE 147

	LD	A,(IX+-22)
	OR	A,A
	JR	Z,L_34
;  148	        //PrintCenteredX(" UP ",10);
;  149	        startName--;
.LINE 149

	LD	IY,(IX+-3)
	LEA	IY,IY+-1
	LD	(IX+-3),IY
;  150	        /*checks if startName underflowed from 0 to 16 million or something.
;  151	        * Whatever the number, it shouldn't be less than the max number of images possible*/
;  152	        if (startName>MAX_IMAGES)
.LINE 152

	LD	BC,IY
	LD	HL,936
	OR	A,A
	SBC	HL,BC
	JR	NC,L_29
;  153	        startName=0;
.LINE 153

	LD	BC,0
	LD	(IX+-3),BC
L_29:
;  154	        printNames(startName, picNames, pics);
.LINE 154

	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_printNames
	POP	BC
	POP	BC
	POP	BC
;  155	        DrawImage(startName,320,240);
.LINE 155

	LD	BC,240
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_DrawImage
	POP	BC
	POP	BC
	POP	BC
;  156	      }
;  157	    }
;  158	  }   while(kb_Data[6]!=kb_Clear);
L_34:
.LINE 158

	LD	A,(16056348)
	CP	A,64
	JR	NZ,L_33
;  159	
;  160	  free(picNames);
.LINE 160

	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_free
	POP	BC
;  161	}
.LINE 161

	LD	SP,IX
	POP	IX
	RET	


;**************************** _DisplayHomeScreen ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;_DrawImage                          IMPORT  -----   function
;_printNames                         IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_ti_Seek                            IMPORT  -----   function
;_gfx_VertLine                       IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_gfx_SetTextBGColor                 IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gfx_FillScreen                     IMPORT  -----   function
;_ti_Open                            IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;G_5                                  IX-35      3   variable
;G_4                                  IX-32      3   variable
;G_6                                  IX-29      3   variable
;G_1                                  IX-26      3   variable
;down                                 IX-23      1   variable
;up                                   IX-22      1   variable
;G_2                                  IX-21      3   variable
;Ypos                                 IX-18      1   variable
;G_0                                  IX-17      3   variable
;G_3                                  IX-14      3   variable
;key                                  IX-11      1   variable
;database                             IX-10      1   variable
;picNames                              IX-9      3   variable
;i                                     IX-6      3   variable
;startName                             IX-3      3   variable
;pics                                  IX+6      3   parameter


; Stack Frame Size: 44 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "DisplayHomeScreen",161,"_DisplayHomeScreen"
	SEGMENT STRSECT
L__4:
	DB	"r"
	DB	0
L__5:
	DB	"HDPICDB"
	DB	0
	SEGMENT CODE
;  162	
;  163	/* Draws the image stored in database at position startName.
;  164	* Draws the image at location x,y starting at top left corner.
;  165	* If x=-1 then make image horizontally centered in the screen.
;  166	* If y=-1 then make image vertically centered on the screen.
;  167	* Image will automatically be resized to same aspect ratio so you just set the max width and height (4,3 will fit the screen normally)
;  168	*
;  169	*/
;  170	void DrawImage(uint24_t picName, uint24_t maxWidth, uint24_t maxHeight){
_DrawImage:
.DEFINE "_DrawImage"

.VALUE _DrawImage

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "DrawImage",170,"_DrawImage"

.LINE 170

.DEFINE "picName"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

.DEFINE "maxWidth"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "maxHeight"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "database"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "squareSlot"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "palSlot"

.CLASS 65

.VALUE -3

.TYPE 12

.ENDEF

.DEFINE "heightSquares"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "xSquare"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "ySquare"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

.DEFINE "scale"

.CLASS 65

.VALUE -16

.TYPE 6

.ENDEF

.DEFINE "maxHSquares"

.CLASS 65

.VALUE -19

.TYPE 14

.ENDEF

.DEFINE "widthSquares"

.CLASS 65

.VALUE -22

.TYPE 14

.ENDEF

.DEFINE "outputImg"

.CLASS 65

.VALUE -25

.TAG "NONAME11"

.TYPE 40

.ENDEF

.DEFINE "imgWH"

.CLASS 65

.VALUE -31

.DIM 6

.TYPE 98

.ENDEF

.DEFINE "maxWSquares"

.CLASS 65

.VALUE -34

.TYPE 14

.ENDEF

.DEFINE "imgID"

.CLASS 65

.VALUE -36

.DIM 2

.TYPE 98

.ENDEF

.DEFINE "srcImg"

.CLASS 65

.VALUE -39

.TAG "NONAME11"

.TYPE 40

.ENDEF

.DEFINE "searchName"

.CLASS 65

.VALUE -48

.DIM 9

.TYPE 98

.ENDEF

.DEFINE "palName"

.CLASS 65

.VALUE -57

.DIM 9

.TYPE 98

.ENDEF

.DEFINE "palPtr"

.CLASS 65

.VALUE -825

.DIM 256

.TYPE 365

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-836
	ADD	HL,SP
	LD	SP,HL
;  171	  ti_var_t database = ti_Open("HDPICDB","r"),squareSlot,palSlot;
.LINE 171

	LD	BC,L__20
	PUSH	BC
	LD	BC,L__21
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-1),A
;  172	  char imgWH[6], imgID[2], searchName[9], palName[9];
;  173	  uint24_t i=0,widthSquares=0,heightSquares=0, maxWSquares=0,maxHSquares=0,widthPx=0,heightPx=0,xSquare=0, newWpx=0, newHpx=0,ySquare=0,xOffsetSquare=0,yOffsetSquare=0;
;  174	  uint16_t *palPtr[256];
;  175	  gfx_sprite_t *outputImg,*srcImg;
;  176	  double scale=1;
.LINE 176

	LD	BC,8388608
	LD	A,63
	LD	(IX+-16),BC
	LD	(IX+-13),A
;  177	  gfx_FillScreen(0);
.LINE 177

	LD	BC,0
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  178	
;  179	  //seeks past header (8bytes), imgName, and unselected images
;  180	  ti_Seek(16+(16*picName),SEEK_CUR,database);
.LINE 180

	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+6)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,HL
	LEA	BC,IY+16
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  181	  //reads the image letter ID (2 bytes)
;  182	  ti_Read(imgID,2,1,database);
.LINE 182

	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+-36
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  183	  //reads the image width/height (6 bytes)
;  184	  ti_Read(imgWH,6,1,database);
.LINE 184

	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,6
	PUSH	BC
	PEA	IX+-31
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  185	  //closes database
;  186	  ti_Close(database);
.LINE 186

	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
;  187	
;  188	  //Converts the width/height from a char array into two integers by converting char into decimal value
;  189	  //then subtracting 48 to get the actuall number.
;  190	  gfx_SetTextScale(1,1);
.LINE 190

	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  191	  //gfx_PrintStringXY(imgWH,170,10);
;  192	  dbg_sprintf(dbgout,"imgWH: %s \n", imgWH);
.LINE 192

	PEA	IX+-31
	LD	BC,L__22
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;  193	
;  194	  //converts the char numbers into uint numbers
;  195	  widthSquares= ((uint24_t)imgWH[0]-48)*100+((uint24_t)imgWH[1]-48)*10+(uint24_t)imgWH[2]-48;
.LINE 195

	LD	A,(IX+-31)
	SEXT	HL
	LD	L,(IX+-31)
	LD	IY,HL
	LEA	HL,IY+-48
	LD	A,100
	CALL	__imul_b
	LD	BC,HL
	LEA	HL,IX+-31
	INC	HL
	LD	A,(HL)
	LD	D,A
	SEXT	HL
	LD	L,D
	LD	IY,HL
	LEA	HL,IY+-48
	LD	A,10
	CALL	__imul_b
	ADD	HL,BC
	LD	BC,HL
	LEA	HL,IX+-29
	LD	A,(HL)
	LD	D,A
	SEXT	HL
	LD	L,D
	ADD	HL,BC
	LD	IY,HL
	LEA	BC,IY+-48
	LD	(IX+-22),BC
;  196	  heightSquares=((uint24_t)imgWH[3]-48)*100+((uint24_t)imgWH[4]-48)*10+(uint24_t)imgWH[5]-48;
.LINE 196

	LEA	HL,IX+-28
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	HL,IY+-48
	LD	A,100
	CALL	__imul_b
	LD	BC,HL
	LEA	HL,IX+-27
	LD	A,(HL)
	LD	D,A
	SEXT	HL
	LD	L,D
	LD	IY,HL
	LEA	HL,IY+-48
	LD	A,10
	CALL	__imul_b
	ADD	HL,BC
	LD	BC,HL
	LEA	HL,IX+-26
	LD	A,(HL)
	LD	D,A
	SEXT	HL
	LD	L,D
	ADD	HL,BC
	LD	IY,HL
	LEA	IY,IY+-48
	LD	(IX+-6),IY
;  197	  maxWSquares = (maxWidth/80);
.LINE 197

	LD	BC,80
	LD	HL,(IX+9)
	CALL	__idivu
	LD	(IX+-34),HL
;  198	  maxHSquares = (maxHeight/80);
.LINE 198

	LD	BC,80
	LD	HL,(IX+12)
	CALL	__idivu
	LD	(IX+-19),HL
;  199	  dbg_sprintf(dbgout,"maxWS: %d\nwidthS: %d\nmaxHS: %d\nheightS: %d\n",maxWSquares,widthSquares,maxHSquares,heightSquares);
.LINE 199

	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,(IX+-19)
	PUSH	BC
	LD	BC,(IX+-22)
	PUSH	BC
	LD	BC,(IX+-34)
	PUSH	BC
	LD	BC,L__23
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	PUSH	BC
	PUSH	HL
	LD	HL,IY
	LD	BC,-836
	CALL	__istix
	POP	HL
	POP	BC
	CALL	_sprintf
	PUSH	BC
	LD	BC,-836
	PUSH	HL
	CALL	__ildix
	LD	IY,HL
	POP	HL
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  200	
;  201	  //resizes image if it's too big
;  202	  if(widthSquares>maxWSquares){
.LINE 202

	LD	BC,(IX+-22)
	LD	HL,(IX+-34)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_40
;  203	    dbg_sprintf(dbgout,"\nPath 1 ");
.LINE 203

	LD	BC,L__25
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	PUSH	BC
	PUSH	HL
	LD	HL,IY
	LD	BC,-836
	CALL	__istix
	POP	HL
	POP	BC
	CALL	_sprintf
	PUSH	BC
	LD	BC,-836
	PUSH	HL
	CALL	__ildix
	LD	IY,HL
	POP	HL
	POP	BC
	POP	BC
	POP	BC
;  204	    scale = maxWSquares/widthSquares;
.LINE 204

	LD	HL,(IX+-34)
	LD	BC,(IX+-22)
	CALL	__idivu
	LD	BC,HL
	XOR	A,A
	CALL	__ultof
	LD	(IX+-16),BC
	LD	(IX+-13),A
;  205	    if(heightSquares*scale>maxHSquares){
.LINE 205

	LD	BC,(IX+-6)
	XOR	A,A
	CALL	__ultof
	LD	HL,(IX+-16)
	LD	E,(IX+-13)
	CALL	__fmul
	LD	HL,BC
	PUSH	BC
	LD	BC,-831	; spill
	CALL	__istix
	POP	BC
	LD	H,A
	PUSH	IY
	PUSH	BC
	LD	IY,-833	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),H
	POP	BC
	POP	IY
	LD	BC,(IX+-19)
	XOR	A,A
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	PUSH	IY
	PUSH	BC
	LD	IY,-832	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),H
	LD	IY,-833	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	H,(IY)
	POP	BC
	POP	IY
	LD	A,H
	PUSH	IY
	PUSH	BC
	LD	IY,-832	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	H,(IY)
	POP	BC
	POP	IY
	PUSH	BC
	LD	BC,-828	; spill
	CALL	__istix
	LD	BC,-831	; unspill
	CALL	__ildix
	POP	BC
	LD	BC,HL
	PUSH	BC
	LD	BC,-828	; unspill
	CALL	__ildix
	POP	BC
	CALL	__fcmp
	JP	P,L_41
;  206	      dbg_sprintf(dbgout,"\nPath 2 ");
.LINE 206

	LD	BC,L__27
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  207	
;  208	      scale = maxHSquares/heightSquares;
.LINE 208

	LD	HL,(IX+-19)
	LD	BC,(IX+-6)
	CALL	__idivu
	LD	BC,HL
	XOR	A,A
	CALL	__ultof
	LD	(IX+-16),BC
	LD	(IX+-13),A
;  209	    }
;  210	  }else  if(heightSquares>maxHSquares){
.LINE 210

	JR	L_41
L_40:
	LD	BC,(IX+-6)
	LD	HL,(IX+-19)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_41
;  211	    dbg_sprintf(dbgout,"\nPath 3 ");
.LINE 211

	LD	BC,L__29
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
;  212	
;  213	    scale = maxHSquares/heightSquares;
.LINE 213

	LD	HL,(IX+-19)
	LD	BC,(IX+-6)
	CALL	__idivu
	LD	BC,HL
	XOR	A,A
	CALL	__ultof
	LD	(IX+-16),BC
	LD	(IX+-13),A
;  214	  }
L_41:
.LINE 214

;  215	  dbg_sprintf(dbgout,"\nScale int: %d \nChanged WH %f",scale,((double)SQUARE_WIDTH_AND_HEIGHT*scale));
.LINE 215

	LD	HL,10485760
	LD	E,66
	LD	BC,(IX+-16)
	LD	A,(IX+-13)
	CALL	__fmul
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	C,(IX+-13)
	PUSH	BC
	LD	BC,(IX+-16)
	PUSH	BC
	LD	BC,L__30
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  216	
;  217	    //allocates memory for outputImg according to scale
;  218	    outputImg = gfx_MallocSprite((double)SQUARE_WIDTH_AND_HEIGHT*scale,(double)SQUARE_WIDTH_AND_HEIGHT*scale);
.LINE 218

	LD	HL,10485760
	LD	E,66
	LD	BC,(IX+-16)
	LD	A,(IX+-13)
	CALL	__fmul
	LD	DE,BC
	LD	H,A
	LD	BC,_malloc
	PUSH	BC
	LD	BC,DE
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	A,H
	LD	BC,DE
	CALL	__ftol
	LD	B,0
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-25),HL
;  219	    if (!outputImg){
.LINE 219

	CALL	__icmpzero
	JR	NZ,L_46
;  220	      PrintCenteredX("Failed to allocate memory!",130);
.LINE 220

	LD	BC,130
	PUSH	BC
	LD	BC,L__32
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  221	      while(!os_GetCSC());
L_43:
.LINE 221

	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_43
;  222	      ti_CloseAll();
.LINE 222

	CALL	_ti_CloseAll
;  223	      return;
.LINE 223

	JR	L_66
;  224	    }
L_46:
.LINE 224

;  225	
;  226	
;  227	    //sets correct palettes
;  228	    sprintf(palName, "HP%.2s0000\0",imgID);
.LINE 228

	PEA	IX+-36
	LD	BC,L__34
	PUSH	BC
	PEA	IX+-57
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;  229	    palSlot = ti_Open(palName,"r");
.LINE 229

	LD	BC,L__35
	PUSH	BC
	PEA	IX+-57
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-3),A
;  230	    if (!palSlot){
.LINE 230

	OR	A,A
	JR	NZ,L_51
;  231	      PrintCenteredX(palName,120);
.LINE 231

	LD	BC,120
	PUSH	BC
	PEA	IX+-57
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  232	      PrintCenteredX("Palette does not exist!",130);
.LINE 232

	LD	BC,130
	PUSH	BC
	LD	BC,L__37
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  233	      while(!os_GetCSC());
L_48:
.LINE 233

	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_48
;  234	      ti_CloseAll();
.LINE 234

	CALL	_ti_CloseAll
;  235	      return;
.LINE 235

	JR	L_66
;  236	    }
L_51:
.LINE 236

;  237	
;  238	    //gfx_SetDrawBuffer();
;  239	    ti_Seek(24,SEEK_SET,palSlot);
.LINE 239

	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,24
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  240	    *palPtr = ti_GetDataPtr(palSlot);
.LINE 240

	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	CALL	_ti_GetDataPtr
	POP	BC
	LD	BC,-825
	CALL	__istix
;  241	    gfx_SetPalette(*palPtr,512,0);
.LINE 241

	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,-825
	CALL	__ildix
	PUSH	HL
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  242	    ti_Close(palSlot);
.LINE 242

	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
;  243	
;  244	    //Displays all the images
;  245	    for(xSquare=0;xSquare<(widthSquares+1);xSquare++){
.LINE 245

	LD	BC,0
	LD	(IX+-9),BC
	JR	L_64
L_62:
;  246	      for(ySquare=0;ySquare<(heightSquares+1);ySquare++){
.LINE 246

	LD	BC,0
	LD	(IX+-12),BC
	JR	L_61
L_59:
;  247	        sprintf(searchName, "%.2s%03u%03u\0",imgID, xSquare, ySquare);//combines the separate parts into one name to search for
.LINE 247

	LD	BC,(IX+-12)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	PEA	IX+-36
	LD	BC,L__39
	PUSH	BC
	PEA	IX+-48
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  248	
;  249	        /*This opens the variable with the name that was just assembled.
;  250	        * It then gets the pointer to that and stores it in a graphics variable
;  251	        */
;  252	        squareSlot = ti_Open(searchName,"r");
.LINE 252

	LD	BC,L__40
	PUSH	BC
	PEA	IX+-48
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-2),A
;  253	        if (!squareSlot){
.LINE 253

	OR	A,A
	JR	NZ,L_58
;  254	          PrintCenteredX(searchName,120);
.LINE 254

	LD	BC,120
	PUSH	BC
	PEA	IX+-48
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  255	          PrintCentered("Square doesn't exist!");
.LINE 255

	LD	BC,L__42
	PUSH	BC
	CALL	_PrintCentered
	POP	BC
;  256	          while(!os_GetCSC());
L_55:
.LINE 256

	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_55
;  257	          ti_CloseAll();
.LINE 257

	CALL	_ti_CloseAll
;  258	          return;
.LINE 258

	JR	L_66
;  259	        }
L_58:
.LINE 259

;  260	        //seeks past header
;  261	        ti_Seek(16,SEEK_CUR,squareSlot);
.LINE 261

	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  262	        //store the original image into srcImg
;  263	        srcImg = (gfx_sprite_t*)ti_GetDataPtr(squareSlot);
.LINE 263

	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	CALL	_ti_GetDataPtr
	POP	BC
	LD	(IX+-39),HL
;  264	        //resizes it to outputImg size
;  265	        gfx_ScaleSprite(srcImg,outputImg);
.LINE 265

	LD	BC,(IX+-25)
	PUSH	BC
	LD	BC,(IX+-39)
	PUSH	BC
	CALL	_gfx_ScaleSprite
	POP	BC
	POP	BC
;  266	
;  267	        //displays the output image
;  268	        gfx_ScaledSprite_NoClip(outputImg,xSquare*SQUARE_WIDTH_AND_HEIGHT,ySquare*SQUARE_WIDTH_AND_HEIGHT,1,1);
.LINE 268

	LD	BC,1
	PUSH	BC
	PUSH	BC
	LD	B,(IX+-12)
	LD	C,80
	MLT	BC
	LD	B,0
	PUSH	BC
	LD	HL,(IX+-9)
	LD	A,80
	CALL	__imul_b
	PUSH	HL
	LD	BC,(IX+-25)
	PUSH	BC
	CALL	_gfx_ScaledSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  269	
;  270	        //cleans up
;  271	        ti_Close(squareSlot);
.LINE 271

	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
	LD	BC,(IX+-12)
	INC	BC
	LD	(IX+-12),BC
;  272	      }
L_61:
.LINE 272

	LD	BC,(IX+-6)
	INC	BC
	LD	HL,(IX+-12)
	OR	A,A
	SBC	HL,BC
	JR	C,L_59
	LD	BC,(IX+-9)
	INC	BC
	LD	(IX+-9),BC
;  273	    }
L_64:
.LINE 273

	LD	BC,(IX+-22)
	INC	BC
	LD	HL,(IX+-9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_62
;  274	    free(outputImg);
.LINE 274

	LD	BC,(IX+-25)
	PUSH	BC
	CALL	_free
	POP	BC
;  275	  }
L_66:
.LINE 275

	LD	SP,IX
	POP	IX
	RET	


;**************************** _DrawImage ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_gfx_ScaledSprite_NoClip            IMPORT  -----   function
;_gfx_ScaleSprite                    IMPORT  -----   function
;_PrintCentered                      IMPORT  -----   function
;_gfx_SetPalette                     IMPORT  -----   function
;_ti_GetDataPtr                      IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_PrintCenteredX                     IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_gfx_AllocSprite                    IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;_gfx_SetTextScale                   IMPORT  -----   function
;_ti_Close                           IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_ti_Seek                            IMPORT  -----   function
;_gfx_FillScreen                     IMPORT  -----   function
;_ti_Open                            IMPORT  -----   function
;palPtr                              IX-825    768   variable
;palName                              IX-57      9   variable
;searchName                           IX-48      9   variable
;srcImg                               IX-39      3   variable
;imgID                                IX-36      2   variable
;maxWSquares                          IX-34      3   variable
;imgWH                                IX-31      6   variable
;outputImg                            IX-25      3   variable
;widthSquares                         IX-22      3   variable
;maxHSquares                          IX-19      3   variable
;scale                                IX-16      4   variable
;ySquare                              IX-12      3   variable
;xSquare                               IX-9      3   variable
;heightSquares                         IX-6      3   variable
;palSlot                               IX-3      1   variable
;squareSlot                            IX-2      1   variable
;database                              IX-1      1   variable
;maxHeight                            IX+12      3   parameter
;maxWidth                              IX+9      3   parameter
;picName                               IX+6      3   parameter


; Stack Frame Size: 851 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "DrawImage",275,"_DrawImage"
	SEGMENT STRSECT
L__20:
	DB	"r"
	DB	0
L__21:
	DB	"HDPICDB"
	DB	0
L__22:
	DB	"imgWH: %s "
	DB	10,0
L__23:
	DB	"maxWS: %d"
	DB	10
	DB	"widthS: %d"
	DB	10
	DB	"maxHS: %d"
	DB	10
	DB	"heightS: %d"
	DB	10,0
L__25:
	DB	10
	DB	"Path 1 "
	DB	0
L__27:
	DB	10
	DB	"Path 2 "
	DB	0
L__29:
	DB	10
	DB	"Path 3 "
	DB	0
L__30:
	DB	10
	DB	"Scale int: %d "
	DB	10
	DB	"Changed WH %f"
	DB	0
L__32:
	DB	"Failed to allocate memory!"
	DB	0
L__34:
	DB	"HP%.2s0000"
	DB	0,0
L__35:
	DB	"r"
	DB	0
L__37:
	DB	"Palette does not exist!"
	DB	0
L__39:
	DB	"%.2s%03u%03u"
	DB	0,0
L__40:
	DB	"r"
	DB	0
L__42:
	DB	"Square doesn't exist!"
	DB	0
	SEGMENT CODE
;  276	
;  277	
;  278	  /* This UI keeps the user selection in the middle of the screen. */
;  279	  void printNames(uint24_t startName, char *picNames, uint24_t numOfPics){
_printNames:
.DEFINE "_printNames"

.VALUE _printNames

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "printNames",279,"_printNames"

.LINE 279

.DEFINE "startName"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

.DEFINE "picNames"

.CLASS 65

.VALUE 9

.TYPE 34

.ENDEF

.DEFINE "numOfPics"

.CLASS 65

.VALUE 12

.TYPE 14

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "curName"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "Yoffset"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-12
	LD	SP,HL
;  280	    uint24_t i, Yoffset=0, y=0, curName=0;
.LINE 280

	LD	BC,0
	LD	(IX+-12),BC
	LD	(IX+-6),BC
;  281	
;  282	    //clears old text and sets up for new text
;  283	    gfx_SetTextScale(2,2);
.LINE 283

	LD	BC,2
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  284	    gfx_SetColor(0);
.LINE 284

	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  285	    gfx_FillRectangle_NoClip(0,0,140,240);
.LINE 285

	LD	BC,240
	PUSH	BC
	LD	BC,140
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  286	    gfx_SetColor(255);
.LINE 286

	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  287	
;  288	    //re-draws UI lines
;  289	    gfx_HorizLine_NoClip(0,120,6);
.LINE 289

	LD	BC,6
	PUSH	BC
	LD	BC,120
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gfx_HorizLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  290	    gfx_HorizLine_NoClip(136,120,5);
.LINE 290

	LD	BC,5
	PUSH	BC
	LD	BC,120
	PUSH	BC
	LD	BC,136
	PUSH	BC
	CALL	_gfx_HorizLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  291	    gfx_HorizLine_NoClip(6,110,130);
.LINE 291

	LD	BC,130
	PUSH	BC
	LD	BC,110
	PUSH	BC
	LD	BC,6
	PUSH	BC
	CALL	_gfx_HorizLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  292	    gfx_HorizLine_NoClip(6,130,130);
.LINE 292

	LD	BC,130
	PUSH	BC
	PUSH	BC
	LD	BC,6
	PUSH	BC
	CALL	_gfx_HorizLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  293	    gfx_VertLine_NoClip(6,110,20);
.LINE 293

	LD	BC,20
	PUSH	BC
	LD	BC,110
	PUSH	BC
	LD	BC,6
	PUSH	BC
	CALL	_gfx_VertLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  294	    gfx_VertLine_NoClip(136,110,21);
.LINE 294

	LD	BC,21
	PUSH	BC
	LD	BC,110
	PUSH	BC
	LD	BC,136
	PUSH	BC
	CALL	_gfx_VertLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  295	
;  296	    /*if the selected start name is under 4, that means we need to start drawing
;  297	    * farther down the screen for the text to go in the right spot */
;  298	    if(startName<4){
.LINE 298

	LD	BC,4
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_68
;  299	      Yoffset = 75 - startName * Y_SPACING;
.LINE 299

	LD	HL,(IX+6)
	LD	A,25
	CALL	__imul_b
	LD	BC,HL
	LD	HL,75
	OR	A,A
	SBC	HL,BC
	LD	(IX+-12),HL
;  300	      startName = 0;
.LINE 300

	LD	BC,0
	LD	(IX+6),BC
;  301	    }else{
.LINE 301

	JR	L_69
L_68:
;  302	      startName-=4;
.LINE 302

	LD	IY,(IX+6)
	LEA	IY,IY+-4
	LD	(IX+6),IY
;  303	    }
L_69:
.LINE 303

;  304	    curName=startName;
.LINE 304

	LD	BC,(IX+6)
	LD	(IX+-9),BC
;  305	
;  306	
;  307	    /* draw the text on the screen. Starts displaying the name at element start
;  308	    * then iterates until out of pics or about to draw off the screen */
;  309	    for(i=0;i<numOfPics && y<180;i++){
.LINE 309

	LD	BC,0
	LD	(IX+-3),BC
	JR	L_75
L_73:
;  310	      //calculates where the text should be drawn
;  311	      y = i * Y_SPACING + Y_MARGIN + Yoffset;
.LINE 311

	LD	HL,(IX+-3)
	LD	A,25
	CALL	__imul_b
	LD	IY,HL
	LEA	HL,IY+38
	LD	BC,(IX+-12)
	ADD	HL,BC
	LD	(IX+-6),HL
;  312	
;  313	      //Prints out the correct name
;  314	      gfx_PrintStringXY(&picNames[curName++*BYTES_PER_IMAGE_NAME],X_MARGIN,y);
.LINE 314

	LD	BC,(IX+-9)
	LD	DE,(IX+-9)
	INC	DE
	LD	(IX+-9),DE
	LD	DE,(IX+-6)
	PUSH	DE
	LD	DE,8
	PUSH	DE
	LD	HL,9
	CALL	__imulu
	LD	BC,(IX+9)
	ADD	HL,BC
	PUSH	HL
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  315	      //while(!os_GetCSC());
;  316	
;  317	    }
L_75:
.LINE 317

	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_76
	LD	BC,180
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	JR	C,L_73
L_76:
;  318	    //slows down scrolling speed
;  319	    delay(150);
.LINE 319

	LD	BC,150
	PUSH	BC
	CALL	_delay
	POP	BC
;  320	  }
.LINE 320

	LD	SP,IX
	POP	IX
	RET	


;**************************** _printNames ***************************
;Name                         Addr/Register   Size   Type
;_delay                              IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;_gfx_VertLine_NoClip                IMPORT  -----   function
;_gfx_HorizLine_NoClip               IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_gfx_SetTextScale                   IMPORT  -----   function
;Yoffset                              IX-12      3   variable
;curName                               IX-9      3   variable
;y                                     IX-6      3   variable
;i                                     IX-3      3   variable
;numOfPics                            IX+12      3   parameter
;picNames                              IX+9      3   parameter
;startName                             IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "printNames",320,"_printNames"
;  321	
;  322	
;  323	
;  324	  /* Rebuilds the database of images on the calculator*/
;  325	  uint24_t rebuildDB(uint8_t p){
_rebuildDB:
.DEFINE "_rebuildDB"

.VALUE _rebuildDB

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "rebuildDB",325,"_rebuildDB"

.LINE 325

.DEFINE "p"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "database"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "imagesFound"

.CLASS 65

.VALUE -4

.TYPE 14

.ENDEF

.DEFINE "palette"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "var_name"

.CLASS 65

.VALUE -8

.TYPE 34

.ENDEF

.DEFINE "search_pos"

.CLASS 65

.VALUE -11

.TYPE 44

.ENDEF

.DEFINE "myData"

.CLASS 65

.VALUE -19

.DIM 8

.TYPE 98

.ENDEF

.DEFINE "imgInfo"

.CLASS 65

.VALUE -67

.DIM 16

.TYPE 354

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-67
	LD	SP,HL
;  326	    char *var_name, *imgInfo[16], nameBuffer[10];
;  327	    uint8_t *search_pos = NULL;
.LINE 327

	LD	BC,0
	LD	(IX+-11),BC
;  328	    uint24_t imagesFound=0;
.LINE 328

	LD	(IX+-4),BC
;  329	    char myData[8]="HDPALV1",names[8];
.LINE 329

	LEA	DE,IX+-19
	LD	HL,_0temp78
	LD	BC,8
	LDIR	
;  330	    ti_var_t database = ti_Open("HDPICDB","w"), palette;
.LINE 330

	LD	BC,L__51
	PUSH	BC
	LD	BC,L__52
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-1),A
;  331	    ti_Write("HDDATV10",8,1,database);//Rewrites the header because w overwrites everything
.LINE 331

	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,L__53
	PUSH	BC
	CALL	_ti_Write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  332	
;  333	    //resets splash screen for new loading SetLoadingBarProgress
;  334	    SplashScreen();
.LINE 334

	CALL	_SplashScreen
;  335	
;  336	    /*
;  337	    * Searches for palettes. This is a lot easier than searching for every single
;  338	    * image square because there's is guarunteed to only be one palette per image.
;  339	    * The palette containts all the useful information such as the image size and
;  340	    * the two letter ID for each appvar. This makes it easy to find every square via a loop.
;  341	    */
;  342	    while((var_name = ti_DetectVar(&search_pos, "HDPALV10", TI_APPVAR_TYPE)) != NULL) {
.LINE 342

	JR	L_79
L_80:
;  343	      //sets progress of how many images were found
;  344	      SetLoadingBarProgress(++imagesFound,MAX_IMAGES);
.LINE 344

	LD	BC,(IX+-4)
	INC	BC
	LD	(IX+-4),BC
	LD	BC,168
	PUSH	BC
	LD	C,(IX+-4)
	LD	B,0
	PUSH	BC
	CALL	_SetLoadingBarProgress
	POP	BC
	POP	BC
;  345	      //finds the name, letter ID, and size of entire image this palette belongs to.
;  346	      palette = ti_Open(var_name,"r");
.LINE 346

	LD	BC,L__54
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-5),A
;  347	      //seeks past useless info
;  348	      ti_Seek(8,SEEK_CUR,palette);
.LINE 348

	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  349	      ti_Seek(16,SEEK_CUR,database);
.LINE 349

	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  350	      //reads the important info (16 bytes)
;  351	      ti_Read(&imgInfo,16,1,palette);
.LINE 351

	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16
	PUSH	BC
	PEA	IX+-67
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  352	      //Writes the info to the database
;  353	      ti_Write(imgInfo,16,1,database);
.LINE 353

	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16
	PUSH	BC
	PEA	IX+-67
	CALL	_ti_Write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  354	      //closes palette for next iteration
;  355	      ti_Close(palette);
.LINE 355

	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
;  356	    }
L_79:
.LINE 356

	LD	BC,21
	PUSH	BC
	LD	BC,L__55
	PUSH	BC
	PEA	IX+-11
	CALL	_ti_DetectVar
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-8),HL
	CALL	__icmpzero
	JR	NZ,L_80
;  357	    //closes the database
;  358	    ti_Close(database);
.LINE 358

	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
;  359	    gfx_End();
.LINE 359

	CALL	_gfx_End
;  360	    ti_SetArchiveStatus(true,database);
.LINE 360

	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_ti_SetArchiveStatus
	POP	BC
	POP	BC
;  361	    gfx_Begin();
.LINE 361

	CALL	_gfx_Begin
;  362	    SplashScreen();
.LINE 362

	CALL	_SplashScreen
;  363	    gfx_SetTextXY(100,195);
.LINE 363

	LD	BC,195
	PUSH	BC
	LD	BC,100
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  364	    gfx_PrintUInt(imagesFound,3);
.LINE 364

	LD	BC,3
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_gfx_PrintUInt
	POP	BC
	POP	BC
;  365	    if (imagesFound==0){
.LINE 365

	LD	HL,(IX+-4)
	CALL	__icmpzero
	JR	NZ,L_83
;  366	      noImagesFound();
.LINE 366

	CALL	_noImagesFound
;  367	    }
L_83:
.LINE 367

;  368	    SetLoadingBarProgress(++p,TASKS_TO_FINISH);
.LINE 368

	INC	(IX+6)
	LD	BC,2
	PUSH	BC
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	CALL	_SetLoadingBarProgress
	POP	BC
	POP	BC
;  369	
;  370	
;  371	
;  372	    return imagesFound;
.LINE 372

	LD	HL,(IX+-4)
;  373	  }
.LINE 373

	LD	SP,IX
	POP	IX
	RET	


;**************************** _rebuildDB ***************************
;Name                         Addr/Register   Size   Type
;_noImagesFound                      IMPORT  -----   function
;_gfx_PrintUInt                      IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_ti_SetArchiveStatus                IMPORT  -----   function
;_gfx_End                            IMPORT  -----   function
;_ti_DetectVar                       IMPORT  -----   function
;_ti_Close                           IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_ti_Seek                            IMPORT  -----   function
;_SetLoadingBarProgress              IMPORT  -----   function
;_SplashScreen                       IMPORT  -----   function
;_ti_Write                           IMPORT  -----   function
;_ti_Open                            IMPORT  -----   function
;_0temp78                            STATIC      8   variable
;imgInfo                              IX-67     48   variable
;myData                               IX-19      8   variable
;search_pos                           IX-11      3   variable
;var_name                              IX-8      3   variable
;palette                               IX-5      1   variable
;imagesFound                           IX-4      3   variable
;database                              IX-1      1   variable
;p                                     IX+6      1   parameter


; Stack Frame Size: 76 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "rebuildDB",373,"_rebuildDB"
	SEGMENT STRSECT
L__51:
	DB	"w"
	DB	0
L__52:
	DB	"HDPICDB"
	DB	0
L__53:
	DB	"HDDATV10"
	DB	0
L__54:
	DB	"r"
	DB	0
L__55:
	DB	"HDPALV10"
	DB	0
	SEGMENT TEXT
_0temp78:
	DB	72
	DB	68
	DB	80
	DB	65
	DB	76
	DB	86
	DB	49
	DB	0
	SEGMENT CODE
;  374	
;  375	  void noImagesFound(){
_noImagesFound:
.DEFINE "_noImagesFound"

.VALUE _noImagesFound

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "noImagesFound",375,"_noImagesFound"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  376	    gfx_SetTextFGColor(192);
.LINE 376

	LD	BC,192
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  377	    PrintCenteredX("No Pictures Detected!",1);
.LINE 377

	LD	BC,1
	PUSH	BC
	LD	BC,L__59
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  378	    gfx_SetTextFGColor(0);
.LINE 378

	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  379	    PrintCenteredX("Convert some images and send them to your",11);
.LINE 379

	LD	BC,11
	PUSH	BC
	LD	BC,L__60
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  380	    PrintCenteredX("calculator using the HDpic converter!",21);
.LINE 380

	LD	BC,21
	PUSH	BC
	LD	BC,L__61
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  381	    PrintCenteredX("Tutorial:  https://youtu.be/s1-g8oSueQg",31);
.LINE 381

	LD	BC,31
	PUSH	BC
	LD	BC,L__62
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  382	    PrintCenteredX("Press any key to quit",41);
.LINE 382

	LD	BC,41
	PUSH	BC
	LD	BC,L__63
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  383	    return;
;  384	  }
.LINE 384

	LD	SP,IX
	POP	IX
	RET	


;**************************** _noImagesFound ***************************
;Name                         Addr/Register   Size   Type
;_PrintCenteredX                     IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "noImagesFound",384,"_noImagesFound"
	SEGMENT STRSECT
L__59:
	DB	"No Pictures Detected!"
	DB	0
L__60:
	DB	"Convert some images and send them to your"
	DB	0
L__61:
	DB	"calculator using the HDpic converter!"
	DB	0
L__62:
	DB	"Tutorial:  https://youtu.be/s1-g8oSueQg"
	DB	0
L__63:
	DB	"Press any key to quit"
	DB	0
	SEGMENT CODE
;  385	
;  386	  //checks if the database is already created. If not, it creates it.
;  387	  uint8_t databaseReady(){
_databaseReady:
.DEFINE "_databaseReady"

.VALUE _databaseReady

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "databaseReady",387,"_databaseReady"

.LINE 387

.DEFINE "ready"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "myAppVar"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "exists"

.CLASS 65

.VALUE -3

.TYPE 12

.ENDEF

.DEFINE "search_pos"

.CLASS 65

.VALUE -6

.TYPE 44

.ENDEF

.DEFINE "var_name"

.CLASS 65

.VALUE -9

.TYPE 34

.ENDEF

.DEFINE "myData"

.CLASS 65

.VALUE -18

.DIM 9

.TYPE 98

.ENDEF

.DEFINE "compare"

.CLASS 65

.VALUE -27

.DIM 9

.TYPE 98

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-27
	LD	SP,HL
;  388	    char *var_name;
;  389	    uint8_t *search_pos = NULL, exists=0, ready = 0;
.LINE 389

	LD	BC,0
	LD	(IX+-6),BC
	LD	(IX+-3),0
;  390	    ti_var_t myAppVar;
;  391	    char myData[9]="HDDATV10"; //remember have one more space than text you're saving for null termiation
.LINE 391

	LEA	DE,IX+-18
	LD	HL,_1temp86
	LD	BC,9
	LDIR	
;  392	    char compare[9]="HDDATV10";
.LINE 392

	LEA	DE,IX+-27
	LD	HL,_2temp87
	LD	BC,9
	LDIR	
;  393	    //tries to find database using known header
;  394	    while((var_name = ti_DetectVar(&search_pos, myData, TI_APPVAR_TYPE)) != NULL) {
.LINE 394

	JR	L_88
L_89:
;  395	      exists=1;
.LINE 395

	LD	(IX+-3),1
;  396	    }
L_88:
.LINE 396

	LD	BC,21
	PUSH	BC
	PEA	IX+-18
	PEA	IX+-6
	CALL	_ti_DetectVar
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-9),HL
	CALL	__icmpzero
	JR	NZ,L_89
;  397	    //if file already exists, simply return
;  398	    if (exists == 1)
.LINE 398

	LD	A,(IX+-3)
	CP	A,1
	JR	NZ,L_101
;  399	    ready = 2;
.LINE 399

	LD	(IX+-1),2
;  400	    else{
.LINE 400

	JR	L_103
L_101:
;  401	      //if file doesn't already exist, create it.
;  402	      //creates the database appvar and writes the header. Checks if wrote successfuly
;  403	      myAppVar=ti_Open("HDPICDB", "w");
.LINE 403

	LD	BC,L__67
	PUSH	BC
	LD	BC,L__68
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-2),A
;  404	      if(!myAppVar)
.LINE 404

;  405	      ready = 3;
.LINE 405

;  406	      if(ti_Write(&myData,8,1,myAppVar)!=1)
.LINE 406

	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	PEA	IX+-18
	CALL	_ti_Write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  407	      ready = 4;
.LINE 407

;  408	      if (ti_Rewind(myAppVar) == EOF)
.LINE 408

	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	CALL	_ti_Rewind
	POP	BC
;  409	      ready = 5;
.LINE 409

;  410	      if (ti_Read(&myData,8, 1, myAppVar) != 1)
.LINE 410

	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	PEA	IX+-18
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  411	      ready = 6;
.LINE 411

;  412	      if (strcmp(myData,compare)!=0)
.LINE 412

	PEA	IX+-27
	PEA	IX+-18
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_98
;  413	      ready = 7;
.LINE 413

	LD	(IX+-1),7
;  414	      else{
.LINE 414

	JR	L_103
L_98:
;  415	        ready = 1;
.LINE 415

	LD	(IX+-1),1
;  416	      }
;  417	    }
L_103:
.LINE 417

;  418	    ti_CloseAll();
.LINE 418

	CALL	_ti_CloseAll
;  419	
;  420	    //checks what happened
;  421	    if(ready==1){
.LINE 421

	LD	A,(IX+-1)
	CP	A,1
	JR	NZ,L_107
;  422	      gfx_SetTextFGColor(195);
.LINE 422

	LD	BC,195
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  423	      PrintCenteredX("created",180);
.LINE 423

	LD	BC,180
	PUSH	BC
	LD	BC,L__75
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  424	      return 1;
.LINE 424

	LD	A,1
	JR	L_108
;  425	    }else if(ready==2){
L_107:
.LINE 425

	LD	A,(IX+-1)
	CP	A,2
	JR	NZ,L_105
;  426	      gfx_SetTextFGColor(004);
.LINE 426

	LD	BC,4
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  427	      PrintCenteredX("exists",180);
.LINE 427

	LD	BC,180
	PUSH	BC
	LD	BC,L__77
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  428	      return 2;
.LINE 428

	LD	A,2
	JR	L_108
;  429	    }else{
L_105:
.LINE 429

;  430	      gfx_SetTextFGColor(224);
.LINE 430

	LD	BC,224
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  431	      PrintCenteredX("failure",180);
.LINE 431

	LD	BC,180
	PUSH	BC
	LD	BC,L__78
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  432	      gfx_SetTextXY(120,190);
.LINE 432

	LD	BC,190
	PUSH	BC
	LD	BC,120
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  433	      gfx_PrintUInt(ready,1);
.LINE 433

	LD	BC,1
	PUSH	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_gfx_PrintUInt
	POP	BC
	POP	BC
;  434	      return 0;
.LINE 434

	XOR	A,A
;  435	    }
;  436	
;  437	
;  438	  }
L_108:
.LINE 438

	LD	SP,IX
	POP	IX
	RET	


;**************************** _databaseReady ***************************
;Name                         Addr/Register   Size   Type
;_gfx_PrintUInt                      IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_PrintCenteredX                     IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_strcmp                             IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_ti_Rewind                          IMPORT  -----   function
;_ti_Write                           IMPORT  -----   function
;_ti_Open                            IMPORT  -----   function
;_ti_DetectVar                       IMPORT  -----   function
;_2temp87                            STATIC      9   variable
;_1temp86                            STATIC      9   variable
;compare                              IX-27      9   variable
;myData                               IX-18      9   variable
;var_name                              IX-9      3   variable
;search_pos                            IX-6      3   variable
;exists                                IX-3      1   variable
;myAppVar                              IX-2      1   variable
;ready                                 IX-1      1   variable


; Stack Frame Size: 33 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "databaseReady",438,"_databaseReady"
	SEGMENT STRSECT
L__67:
	DB	"w"
	DB	0
L__68:
	DB	"HDPICDB"
	DB	0
L__75:
	DB	"created"
	DB	0
L__77:
	DB	"exists"
	DB	0
L__78:
	DB	"failure"
	DB	0
	SEGMENT TEXT
_1temp86:
	DB	72
	DB	68
	DB	68
	DB	65
	DB	84
	DB	86
	DB	49
	DB	48
	DB	0
_2temp87:
	DB	72
	DB	68
	DB	68
	DB	65
	DB	84
	DB	86
	DB	49
	DB	48
	DB	0
	SEGMENT CODE
;  439	
;  440	  //makes a loading bar and fills it in depending on progress made (p) / tasks left (t)
;  441	  void SetLoadingBarProgress(uint8_t p, uint8_t t){
_SetLoadingBarProgress:
.DEFINE "_SetLoadingBarProgress"

.VALUE _SetLoadingBarProgress

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "SetLoadingBarProgress",441,"_SetLoadingBarProgress"

.LINE 441

.DEFINE "p"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "t"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  442	    p=((double)p/(double)t)*200.0;
.LINE 442

	UEXT	HL
	LD	L,(IX+6)
	LD	A,H
	LD	BC,HL
	CALL	__ultof
	LD	(IX+-1),A
	LD	(IX+-4),BC
	UEXT	HL
	LD	L,(IX+9)
	LD	A,H
	LD	BC,HL
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	LD	A,(IX+-1)
	LD	BC,(IX+-4)
	CALL	__fdiv
	LD	HL,4718592
	LD	E,67
	CALL	__fmul
	CALL	__ftol
	LD	(IX+6),C
;  443	    //ensures loading bar doesn't go past max point
;  444	    if (p>200)
.LINE 444

	LD	A,200
	CP	A,(IX+6)
	JR	NC,L_110
;  445	    p=200;
.LINE 445

	LD	(IX+6),200
L_110:
;  446	
;  447	    gfx_SetColor(128);
.LINE 447

	LD	BC,128
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  448	    gfx_FillRectangle_NoClip(60,153,(uint8_t)p,7);
.LINE 448

	LD	BC,7
	PUSH	BC
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,153
	PUSH	BC
	LD	BC,60
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  449	
;  450	  }
.LINE 450

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SetLoadingBarProgress ***************************
;Name                         Addr/Register   Size   Type
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;t                                     IX+9      1   parameter
;p                                     IX+6      1   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SetLoadingBarProgress",450,"_SetLoadingBarProgress"
;  451	
;  452	  //creates a simple splash screen when program starts
;  453	  void SplashScreen(){
_SplashScreen:
.DEFINE "_SplashScreen"

.VALUE _SplashScreen

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "SplashScreen",453,"_SplashScreen"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  454	    //sets color to grey
;  455	    gfx_SetColor(181);
.LINE 455

	LD	BC,181
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  456	    gfx_FillRectangle_NoClip(60,80,LCD_WIDTH-120,LCD_HEIGHT-160);
.LINE 456

	LD	BC,80
	PUSH	BC
	LD	BC,200
	PUSH	BC
	LD	BC,80
	PUSH	BC
	LD	BC,60
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  457	    /* Print title screen */
;  458	    PrintCentered("HD Picture Viewer");
.LINE 458

	LD	BC,L__82
	PUSH	BC
	CALL	_PrintCentered
	POP	BC
;  459	  }
.LINE 459

	LD	SP,IX
	POP	IX
	RET	


;**************************** _SplashScreen ***************************
;Name                         Addr/Register   Size   Type
;_PrintCentered                      IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "SplashScreen",459,"_SplashScreen"
	SEGMENT STRSECT
L__82:
	DB	"HD Picture Viewer"
	DB	0
	SEGMENT CODE
;  460	
;  461	  /* Prints a screen centered string */
;  462	  void PrintCentered(const char *str)
;  463	  {
_PrintCentered:
.DEFINE "_PrintCentered"

.VALUE _PrintCentered

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "PrintCentered",463,"_PrintCentered"

.LINE 463

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  464	    gfx_PrintStringXY(str,(LCD_WIDTH - gfx_GetStringWidth(str)) / 2, (LCD_HEIGHT - 8) / 2);
.LINE 464

	LD	BC,116
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_GetStringWidth
	POP	BC
	LD	BC,HL
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	LD	A,1
	CALL	__ishru_b
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  465	  }
.LINE 465

	LD	SP,IX
	POP	IX
	RET	


;**************************** _PrintCentered ***************************
;Name                         Addr/Register   Size   Type
;_gfx_GetStringWidth                 IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;str                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "PrintCentered",465,"_PrintCentered"
;  466	  /* Prints a X centered string */
;  467	  void PrintCenteredX(const char *str, uint8_t y)
;  468	  {
_PrintCenteredX:
.DEFINE "_PrintCenteredX"

.VALUE _PrintCenteredX

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "PrintCenteredX",468,"_PrintCenteredX"

.LINE 468

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  469	    gfx_PrintStringXY(str, (LCD_WIDTH - gfx_GetStringWidth(str)) / 2, y);
.LINE 469

	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_GetStringWidth
	POP	BC
	LD	BC,HL
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	LD	A,1
	CALL	__ishru_b
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  470	  }
.LINE 470

	LD	SP,IX
	POP	IX
	RET	


;**************************** _PrintCenteredX ***************************
;Name                         Addr/Register   Size   Type
;_gfx_GetStringWidth                 IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;y                                     IX+9      1   parameter
;str                                   IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "PrintCenteredX",470,"_PrintCenteredX"
;  471	  /* Prints a Y centered string */
;  472	  void PrintCenteredY(const char *str, uint8_t x)
;  473	  {
_PrintCenteredY:
.DEFINE "_PrintCenteredY"

.VALUE _PrintCenteredY

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "PrintCenteredY",473,"_PrintCenteredY"

.LINE 473

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  474	    gfx_PrintStringXY(str, x, (LCD_HEIGHT - 8) / 2);
.LINE 474

	LD	BC,116
	PUSH	BC
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  475	  }
.LINE 475

	LD	SP,IX
	POP	IX
	RET	


;**************************** _PrintCenteredY ***************************
;Name                         Addr/Register   Size   Type
;_gfx_PrintStringXY                  IMPORT  -----   function
;x                                     IX+9      1   parameter
;str                                   IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "PrintCenteredY",475,"_PrintCenteredY"
;  476	
;  477	
;  478	  /* Draw text on the homescreen at the given X/Y location */
;  479	  void printText(int8_t xpos, int8_t ypos, const char *text) {
_printText:
.DEFINE "_printText"

.VALUE _printText

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "printText",479,"_printText"

.LINE 479

.DEFINE "xpos"

.CLASS 65

.VALUE 6

.TYPE 2

.ENDEF

.DEFINE "ypos"

.CLASS 65

.VALUE 9

.TYPE 2

.ENDEF

.DEFINE "text"

.CLASS 65

.VALUE 12

.TYPE 194

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  480	    os_SetCursorPos(ypos, xpos);
.LINE 480

	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	CALL	_os_SetCursorPos
	POP	BC
	POP	BC
;  481	    os_PutStrFull(text);
.LINE 481

	LD	BC,(IX+12)
	PUSH	BC
	CALL	_os_PutStrFull
	POP	BC
;  482	  }
.LINE 482

	LD	SP,IX
	POP	IX
	RET	


;**************************** _printText ***************************
;Name                         Addr/Register   Size   Type
;_os_PutStrFull                      IMPORT  -----   function
;_os_SetCursorPos                    IMPORT  -----   function
;text                                 IX+12      3   parameter
;ypos                                  IX+9      1   parameter
;xpos                                  IX+6      1   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "printText",482,"_printText"
	XREF _strcmp:ROM
	XREF _sprintf:ROM
	XREF _ti_GetDataPtr:ROM
	XREF _ti_SetArchiveStatus:ROM
	XREF _ti_Rewind:ROM
	XREF _ti_Seek:ROM
	XREF _ti_Read:ROM
	XREF _ti_Write:ROM
	XREF _ti_DetectVar:ROM
	XREF _ti_Close:ROM
	XREF _ti_Open:ROM
	XREF _ti_CloseAll:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_GetStringWidth:ROM
	XREF _gfx_ScaleSprite:ROM
	XREF _gfx_ScaledSprite_NoClip:ROM
	XREF _gfx_SetTextBGColor:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintStringXY:ROM
	XREF _gfx_PrintUInt:ROM
	XREF _gfx_SetTextScale:ROM
	XREF _gfx_FillRectangle_NoClip:ROM
	XREF _gfx_VertLine_NoClip:ROM
	XREF _gfx_VertLine:ROM
	XREF _gfx_HorizLine_NoClip:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _os_GetCSC:ROM
	XREF _os_PutStrFull:ROM
	XREF _os_SetCursorPos:ROM
	XREF _delay:ROM
	XREF __idivu:ROM
	XREF __imulu:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fcmp:ROM
	XREF __ftol:ROM
	XREF __ultof:ROM
	XREF __ildix:ROM
	XREF __istix:ROM
	XREF __icmpzero:ROM
	XREF __imul_b:ROM
	XREF __ishru_b:ROM
	XDEF _printText
	XDEF _PrintCenteredY
	XDEF _PrintCenteredX
	XDEF _PrintCentered
	XDEF _SplashScreen
	XDEF _SetLoadingBarProgress
	XDEF _databaseReady
	XDEF _noImagesFound
	XDEF _rebuildDB
	XDEF _printNames
	XDEF _DrawImage
	XDEF _DisplayHomeScreen
	XDEF _main
	END
