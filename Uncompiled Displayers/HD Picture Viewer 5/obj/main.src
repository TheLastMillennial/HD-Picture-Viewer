; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\MAIN.C"
	.assume ADL=1
	SEGMENT CODE
;    1	#include <tice.h>
;    2	#include <graphx.h>
;    3	#include <keypadc.h>
;    4	#include <stdbool.h>
;    5	#include <stddef.h>
;    6	#include <stdint.h>
;    7	#include <stdio.h>
;    8	#include <stdlib.h>
;    9	#include <string.h>
;   10	#include <fileioc.h>
;   11	#include <debug.h>
;   12	#include <math.h>
;   13	#include <compression.h>
;   14	#include "gfx/errorgfx.h"
;   15	
;   16	
;   17	/* globals */
;   18	
;   19	#define BYTES_PER_IMAGE_NAME 9 //8 for image name, 1 for null terminator
;   20	#define MAX_IMAGES 936 //Max images is this because max combinations of appvars goes up to that
;   21	#define TASKS_TO_FINISH 2
;   22	#define X_MARGIN 8
;   23	#define Y_MARGIN 38
;   24	#define Y_SPACING 25
;   25	#define MAX_THUMBNAIL_WIDTH 160
;   26	#define MAX_THUMBNAIL_HEIGHT 240
;   27	#define THUMBNAIL_ZOOM 0
;   28	#define SQUARE_WIDTH_AND_HEIGHT 80
;   29	
;   30	
;   31	
;   32	
;   33	
;   34	/* Function Prototyptes */
;   35	uint8_t databaseReady();
;   36	void DisplayHomeScreen(uint24_t pics);
;   37	void DrawImage(uint24_t picName, uint24_t maxWidth, uint24_t maxHeight);
;   38	void noImagesFound();
;   39	void PrintCentered(const char *str);
;   40	void PrintCenteredX(const char *str, uint8_t y);
;   41	void PrintCenteredY(const char *str, uint8_t x);
;   42	void printNames(uint24_t start, char *picNames, uint24_t numOfPics);
;   43	void printText(int8_t xpos, int8_t ypos, const char *text);
;   44	uint24_t rebuildDB(uint8_t p);
;   45	void SplashScreen();
;   46	void SetLoadingBarProgress(uint8_t p, uint8_t t);
;   47	
;   48	/* Main function, called first */
;   49	int main(void)
;   50	{
_main:
	LD	HL,-4
	CALL	__frameset
;   51	  uint8_t ready=0, tasksFinished = 0;
	LD	(IX+-1),0
;   52	  uint24_t picsDetected=0;
	LD	BC,0
	LD	(IX+-4),BC
;   53	  /* Clear the homescreen */
;   54	  //os_ClrHome();
;   55	
;   56	  gfx_Begin();
	CALL	_gfx_Begin
;   57	  ti_CloseAll();
	CALL	_ti_CloseAll
;   58	  SplashScreen();
	CALL	_SplashScreen
;   59	  SetLoadingBarProgress(++tasksFinished, TASKS_TO_FINISH);
	LD	BC,2
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_SetLoadingBarProgress
	POP	BC
	POP	BC
;   60	  //checks if the database exists and is ready 0 failure; 1 created; 2 exists
;   61	  ready = databaseReady();
	CALL	_databaseReady
	LD	(IX+-1),A
;   62	  if (ready==0)
	OR	A,A
	JR	Z,L_6
;   63	  goto err;
;   64	
;   65	
;   66	  picsDetected=rebuildDB(tasksFinished);
	LD	BC,1
	PUSH	BC
	CALL	_rebuildDB
	POP	BC
	LD	(IX+-4),HL
;   67	  if(picsDetected==0)
	CALL	__icmpzero
	JR	Z,L_6
;   68	  goto err;
;   69	  //returns how many images were found. 0 means quit.
;   70	
;   71	  SetLoadingBarProgress(++tasksFinished,TASKS_TO_FINISH);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	CALL	_SetLoadingBarProgress
	POP	BC
	POP	BC
;   72	  DisplayHomeScreen(picsDetected);
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_DisplayHomeScreen
	POP	BC
;   73	
;   74	  err:
;   75	  /* Waits for a keypress */
;   76	  while (!os_GetCSC());
L_6:
	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_6
;   77	  ti_CloseAll();
	CALL	_ti_CloseAll
;   78	  gfx_End();
	CALL	_gfx_End
	OR	A,A
;   79	
;   80	  /* Return 0 for success */
;   81	  return 0;
	SBC	HL,HL
;   82	
;   83	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_gfx_End                            IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_DisplayHomeScreen                  IMPORT  -----   function
;_rebuildDB                          IMPORT  -----   function
;_databaseReady                      IMPORT  -----   function
;_SetLoadingBarProgress              IMPORT  -----   function
;_SplashScreen                       IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;picsDetected                          IX-4      3   variable
;ready                                 IX-1      1   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;   84	
;   85	/* Functions */
;   86	
;   87	void DisplayHomeScreen(uint24_t pics){
_DisplayHomeScreen:
	LD	HL,-35
	CALL	__frameset
;   88	  char *picNames = malloc(pics*BYTES_PER_IMAGE_NAME); //BYTES_PER_IMAGE_NAME = 9
	LD	HL,(IX+6)
	LD	A,9
	CALL	__imul_b
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+-9),HL
;   89	  ti_var_t database = ti_Open("HDPICDB","r");
	LD	BC,L__4
	PUSH	BC
	LD	BC,L__5
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-10),A
;   90	  uint24_t i,startName=0;
	LD	BC,0
	LD	(IX+-3),BC
;   91	  uint8_t Ypos=10;
	LD	(IX+-18),10
;   92	  kb_key_t key = kb_Data[7];
;   93	  bool up,down,left,right;
;   94	
;   95	
;   96	  //makes the screen black and sets text white
;   97	  gfx_FillScreen(0);
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;   98	  gfx_SetTextFGColor(254);
	LD	BC,254
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;   99	  gfx_SetTextBGColor(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTextBGColor
	POP	BC
;  100	  gfx_SetColor(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  101	  gfx_VertLine(140,20,200);
	LD	BC,200
	PUSH	BC
	LD	BC,20
	PUSH	BC
	LD	BC,140
	PUSH	BC
	CALL	_gfx_VertLine
	POP	BC
	POP	BC
	POP	BC
;  102	
;  103	
;  104	  //seeks to the first image name
;  105	  ti_Seek(8,SEEK_SET,database);
	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,8
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  106	  //PrintCenteredX("Test1",30);
;  107	  //loops through every picture that was detected and store the image name to picNames
;  108	  for(i=0;i<=pics;i++){
	LD	BC,0
	LD	(IX+-6),BC
	JR	L_12
L_10:
;  109	    ti_Read(&picNames[i * BYTES_PER_IMAGE_NAME],8,1,database);
	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	HL,(IX+-6)
	LD	A,9
	CALL	__imul_b
	LD	BC,(IX+-9)
	ADD	HL,BC
	PUSH	HL
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  110	    picNames[i * BYTES_PER_IMAGE_NAME + BYTES_PER_IMAGE_NAME - 1] = 0;
	LD	HL,(IX+-6)
	LD	A,9
	CALL	__imul_b
	LD	IY,HL
	LEA	BC,IY+9
	DEC	BC
	LD	HL,(IX+-9)
	ADD	HL,BC
	LD	(HL),0
;  111	    ti_Seek(8,SEEK_CUR,database);
	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  112	    //PrintCenteredX("Test2",40);
;  113	    Ypos+=15;
	LD	A,(IX+-18)
	ADD	A,15
	LD	(IX+-18),A
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
;  114	    //PrintCenteredX(&picNames[i*BYTES_PER_IMAGE_NAME],Ypos);
;  115	
;  116	  }
L_12:
	LD	BC,(IX+-6)
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_10
;  117	
;  118	  /* Keypress handler */
;  119	  gfx_SetTextXY(10,10);
	LD	BC,10
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  120	  printNames(startName, picNames, pics);
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_printNames
	POP	BC
	POP	BC
	POP	BC
;  121	  DrawImage(startName,320,240);
	LD	BC,240
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_DrawImage
	POP	BC
	POP	BC
	POP	BC
;  122	  do{
L_33:
;  123	    //scans the keys for keypress
;  124	    kb_Scan();
	CALL	_kb_Scan
;  125	    //checks if up or down arrow key were pressed
;  126	    key = kb_Data[7];
	LD	A,(16056350)
	LD	(IX+-11),A
;  127	    down= key & kb_Down;
	AND	A,1
	LD	(IX+-23),A
;  128	    up  = key & kb_Up;
	LD	A,(IX+-11)
	AND	A,8
	LD	(IX+-22),A
;  129	    //if any key was pressed
;  130	    if(key){
	LD	A,(IX+-11)
	OR	A,A
	JR	Z,L_34
;  131	      /* increases the name to start on and redraws the text */
;  132	      if(down){
	LD	A,(IX+-23)
	OR	A,A
	JR	Z,L_31
;  133	        //PrintCenteredX("DOWN",10);
;  134	        startName++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  135	        //make sure user can't scroll down too far
;  136	        if (startName>(pics-1))//If there's more than 4 images, then handle things normally
	LD	IY,(IX+6)
	LEA	IY,IY+-1
	LD	(IX+-17),IY
	LD	(IX+-26),IY
	LD	BC,(IX+-3)
	LD	HL,(IX+-17)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_18
;  137	        startName=pics-1;
	LD	BC,(IX+-17)
	LD	(IX+-26),BC
	LD	BC,(IX+-17)
	LD	(IX+-3),BC
L_18:
;  138	        if (startName>pics-1 && pics-1>0) //makes sure user can't scroll too far when there's only 1 image detected
	LD	BC,(IX+-26)
	LD	(IX+-21),BC
	LD	(IX+-32),BC
	LD	BC,(IX+-3)
	LD	HL,(IX+-21)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_21
	LD	BC,(IX+-21)
	LD	(IX+-32),BC
	LD	BC,(IX+-21)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_21
;  139	        startName=pics;
	LD	BC,(IX+6)
	LD	(IX+-3),BC
L_21:
;  140	        if (startName>pics-2 && pics-2>0) //makes sure user can't scroll too far when there's only 2 images detected
	LD	IY,(IX+6)
	LEA	IY,IY+-2
	LD	(IX+-14),IY
	LD	(IX+-29),IY
	LD	BC,(IX+-3)
	LD	HL,(IX+-14)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_24
	LD	BC,(IX+-14)
	LD	(IX+-29),BC
	LD	BC,(IX+-14)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_24
;  141	        startName=pics-1;
	LD	BC,(IX+-32)
	LD	(IX+-3),BC
L_24:
;  142	        if (startName>pics-3 && pics-3>0) //makes sure user can't scroll too far when there's only 3 images detected
	LD	IY,(IX+6)
	LEA	IY,IY+-3
	LD	(IX+-35),IY
	LD	BC,(IX+-3)
	LD	HL,(IX+-35)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_25
	LD	BC,(IX+-35)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_25
;  143	        startName=pics-2;
	LD	BC,(IX+-29)
	LD	(IX+-3),BC
L_25:
;  144	        printNames(startName, picNames, pics);
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_printNames
	POP	BC
	POP	BC
	POP	BC
;  145	        DrawImage(startName,320,240);
	LD	BC,240
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_DrawImage
	POP	BC
	POP	BC
	POP	BC
;  146	      }
L_31:
;  147	      //key = kb_Data[3];
;  148	
;  149	      /* decreases the name to start on and redraws the text */
;  150	      if(up){
	LD	A,(IX+-22)
	OR	A,A
	JR	Z,L_34
;  151	        //PrintCenteredX(" UP ",10);
;  152	        startName--;
	LD	IY,(IX+-3)
	LEA	IY,IY+-1
	LD	(IX+-3),IY
;  153	        /*checks if startName underflowed from 0 to 16 million or something.
;  154	        * Whatever the number, it shouldn't be less than the max number of images possible*/
;  155	        if (startName>MAX_IMAGES)
	LD	BC,IY
	LD	HL,936
	OR	A,A
	SBC	HL,BC
	JR	NC,L_29
;  156	        startName=0;
	LD	BC,0
	LD	(IX+-3),BC
L_29:
;  157	        printNames(startName, picNames, pics);
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_printNames
	POP	BC
	POP	BC
	POP	BC
;  158	        DrawImage(startName,320,240);
	LD	BC,240
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_DrawImage
	POP	BC
	POP	BC
	POP	BC
;  159	      }
;  160	    }
;  161	  }   while(kb_Data[6]!=kb_Clear);
L_34:
	LD	A,(16056348)
	CP	A,64
	JR	NZ,L_33
;  162	
;  163	  free(picNames);
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_free
	POP	BC
;  164	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _DisplayHomeScreen ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;_DrawImage                          IMPORT  -----   function
;_printNames                         IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_ti_Seek                            IMPORT  -----   function
;_gfx_VertLine                       IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_gfx_SetTextBGColor                 IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gfx_FillScreen                     IMPORT  -----   function
;_ti_Open                            IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;G_5                                  IX-35      3   variable
;G_4                                  IX-32      3   variable
;G_6                                  IX-29      3   variable
;G_1                                  IX-26      3   variable
;down                                 IX-23      1   variable
;up                                   IX-22      1   variable
;G_2                                  IX-21      3   variable
;Ypos                                 IX-18      1   variable
;G_0                                  IX-17      3   variable
;G_3                                  IX-14      3   variable
;key                                  IX-11      1   variable
;database                             IX-10      1   variable
;picNames                              IX-9      3   variable
;i                                     IX-6      3   variable
;startName                             IX-3      3   variable
;pics                                  IX+6      3   parameter


; Stack Frame Size: 44 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__4:
	DB	"r"
	DB	0
L__5:
	DB	"HDPICDB"
	DB	0
	SEGMENT CODE
;  165	
;  166	/* Draws the image stored in database at position startName.
;  167	* Draws the image at location x,y starting at top left corner.
;  168	* If x=-1 then make image horizontally centered in the screen.
;  169	* If y=-1 then make image vertically centered on the screen.
;  170	* Image will automatically be resized to same aspect ratio so you just set the max width and height (4,3 will fit the screen normally)
;  171	*
;  172	*/
;  173	void DrawImage(uint24_t picName, uint24_t maxWidth, uint24_t maxHeight){
_DrawImage:
	LD	HL,-830
	CALL	__frameset
;  174	  ti_var_t database = ti_Open("HDPICDB","r"),squareSlot,palSlot;
	LD	BC,L__20
	PUSH	BC
	LD	BC,L__21
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-1),A
;  175	  char imgWH[6], imgID[2], searchName[9], palName[9];
;  176	  uint24_t i=0,widthSquares=0,heightSquares=0, maxWSquares=0,maxHSquares=0,widthPx=0,heightPx=0,xSquare=0, newWpx=0, newHpx=0,ySquare=0,xOffsetSquare=0,yOffsetSquare=0;
;  177	  uint16_t *palPtr[256];
;  178	  gfx_sprite_t *outputImg,*srcImg, *errorImg;
;  179	  uint24_t scale=1, scaleNum=1, scaleDen =1, newWidthHeight;
;  180	  gfx_FillScreen(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  181	
;  182	  //seeks past header (8bytes), imgName, and unselected images
;  183	  ti_Seek(16+(16*picName),SEEK_CUR,database);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	HL,(IX+6)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,HL
	LEA	BC,IY+16
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  184	  //reads the image letter ID (2 bytes)
;  185	  ti_Read(imgID,2,1,database);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+-23
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  186	  //reads the image width/height (6 bytes)
;  187	  ti_Read(imgWH,6,1,database);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,6
	PUSH	BC
	PEA	IX+-21
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  188	  //closes database
;  189	  ti_Close(database);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
;  190	
;  191	  //Converts the width/height from a char array into two integers by converting char into decimal value
;  192	  //then subtracting 48 to get the actuall number.
;  193	  gfx_SetTextScale(1,1);
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  194	  //gfx_PrintStringXY(imgWH,170,10);
;  195	  dbg_sprintf(dbgout,"imgWH: %s \n", imgWH);
;  196	
;  197	  //converts the char numbers into uint numbers
;  198	  widthSquares= ((uint24_t)imgWH[0]-'0')*100+((uint24_t)imgWH[1]-'0')*10+(uint24_t)imgWH[2]-'0';
	LD	A,(IX+-21)
	SEXT	HL
	LD	L,(IX+-21)
	LD	IY,HL
	LEA	HL,IY+-48
	LD	A,100
	LEA	IY,IX+-21
	CALL	__imul_b
	LD	A,(IY+1)
	LD	B,A
	LD	DE,HL
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	HL,IY+-48
	LEA	IY,IX+-21
	LD	A,10
	CALL	__imul_b
	LD	A,(IY+2)
	ADD	HL,DE
	LD	BC,HL
	LD	D,A
	SEXT	HL
	LD	L,D
	ADD	HL,BC
	LD	IY,HL
	LEA	BC,IY+-48
	LD	(IX+-26),BC
;  199	  heightSquares=((uint24_t)imgWH[3]-'0')*100+((uint24_t)imgWH[4]-'0')*10+(uint24_t)imgWH[5]-'0';
	LEA	HL,IX+-18
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	HL,IY+-48
	LEA	IY,IX+-21
	LD	A,100
	CALL	__imul_b
	LD	A,(IY+4)
	LD	B,A
	LD	DE,HL
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	HL,IY+-48
	LEA	IY,IX+-21
	LD	A,10
	CALL	__imul_b
	LD	A,(IY+5)
	ADD	HL,DE
	LD	BC,HL
	LD	D,A
	SEXT	HL
	LD	L,D
	ADD	HL,BC
	LD	IY,HL
	LEA	IY,IY+-48
	LD	(IX+-15),IY
;  200	  maxWSquares = (maxWidth/80); //todo: [jacobly] I'm saying you should use numTilesAcross * 80 rather than maxWidth / 80
	LD	HL,(IX+9)
	LD	BC,80
	CALL	__idivu
	LD	(IX+-32),HL
;  201	  maxHSquares = (maxHeight/80);
	LD	HL,(IX+12)
	LD	BC,80
	CALL	__idivu
	LD	BC,HL
	LD	(IX+-38),BC
;  202	  dbg_sprintf(dbgout,"maxWS: %d\nwidthS: %d\nmaxHS: %d\nheightS: %d\n",maxWSquares,widthSquares,maxHSquares,heightSquares);
;  203	
;  204	  //NEW
;  205	  if (widthSquares * maxHSquares < heightSquares * maxWSquares) {
	LD	HL,(IX+-26)
	CALL	__imulu
	LD	DE,HL
	LD	HL,(IX+-15)
	LD	BC,(IX+-32)
	CALL	__imulu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JR	NC,L_43
;  206	    scaleNum = maxWSquares;
	LD	BC,(IX+-32)
	LD	(IX+-35),BC
;  207	    scaleDen = widthSquares;
	LD	BC,(IX+-26)
	LD	(IX+-29),BC
;  208	    dbg_sprintf(dbgout,"\nPath 1 ");
	JR	L_45
;  209	  } else {
L_43:
;  210	    scaleNum = maxHSquares;
	LD	BC,(IX+-38)
	LD	(IX+-35),BC
;  211	    scaleDen = heightSquares;
	LD	BC,(IX+-15)
	LD	(IX+-29),BC
;  212	    dbg_sprintf(dbgout,"\nPath 2 ");
;  213	  }
L_45:
;  214	  newWidthHeight = SQUARE_WIDTH_AND_HEIGHT*scaleNum;
	LD	HL,(IX+-35)
	LD	A,80
	CALL	__imul_b
	LD	(IX+-41),HL
;  215	
;  216	  /*
;  217	  [jacobly] so now whenever we want to compute
;  218	  `x * scale`
;  219	  we instead want to compute
;  220	  `x * (scaleNum / scaleDen)`
;  221	  which can now be reordered to use strictly integer math as
;  222	  `(x * scaleNum) / scaleDen`
;  223	
;  224	
;  225	  [jacobly] if you don't know:
;  226	  floorDiv(x, y) := x / y;
;  227	  roundDiv(x, y) := (x + (y / 2)) / y;
;  228	  ceilDiv(x, y) := (x + y - 1) / y;
;  229	  [MateoC] huh I didn't know about roundDiv
;  230	  */
;  231	
;  232	  dbg_sprintf(dbgout,"\nScaleNum: %d \nscaleDen",scaleNum,scaleDen);
;  233	
;  234	  //allocates memory for outputImg according to scale
;  235	  outputImg = gfx_MallocSprite(newWidthHeight/scaleDen,newWidthHeight/scaleDen);
	LD	BC,(IX+-29)
	CALL	__idivu
	LD	DE,HL
	LD	HL,DE
	LD	C,L
	LD	HL,DE
	LD	DE,_malloc
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	C,L
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-12),HL
;  236	  if (!outputImg){
	CALL	__icmpzero
	JR	NZ,L_52
;  237	    PrintCenteredX("Failed to allocate memory!",130);
	LD	BC,130
	PUSH	BC
	LD	BC,L__24
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  238	    while(!os_GetCSC());
L_49:
	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_49
;  239	    ti_CloseAll();
	CALL	_ti_CloseAll
;  240	    return;
	JR	L_76
;  241	  }
L_52:
;  242	
;  243	
;  244	  //sets correct palettes
;  245	  sprintf(palName, "HP%.2s0000\0",imgID);
	PEA	IX+-23
	LD	BC,L__26
	PUSH	BC
	PEA	IX+-53
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;  246	  palSlot = ti_Open(palName,"r");
	LD	BC,L__27
	PUSH	BC
	PEA	IX+-53
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-3),A
;  247	  if (!palSlot){
	OR	A,A
	JR	NZ,L_57
;  248	    PrintCenteredX(palName,120);
	LD	BC,120
	PUSH	BC
	PEA	IX+-53
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  249	    PrintCenteredX("Palette does not exist!",130);
	LD	BC,130
	PUSH	BC
	LD	BC,L__29
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  250	    while(!os_GetCSC());
L_54:
	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_54
;  251	    ti_CloseAll();
	CALL	_ti_CloseAll
;  252	    return;
	JR	L_76
;  253	  }
L_57:
;  254	
;  255	  //gfx_SetDrawBuffer();
;  256	  ti_Seek(24,SEEK_SET,palSlot);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,24
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  257	  *palPtr = ti_GetDataPtr(palSlot);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	CALL	_ti_GetDataPtr
	POP	BC
	LD	BC,-830
	CALL	__istix
;  258	  gfx_SetPalette(*palPtr,512,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,-830
	CALL	__ildix
	PUSH	HL
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  259	  ti_Close(palSlot);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
;  260	
;  261	dbg_sprintf(dbgout,"-------------------------");
;  262	  //Displays all the images
;  263	  for(xSquare=(widthSquares);xSquare>0;xSquare--){
	LD	BC,(IX+-26)
	LD	(IX+-6),BC
	JR	L_73
L_71:
;  264	    for(ySquare=0;ySquare<(heightSquares+1);ySquare++){
	LD	BC,0
	LD	(IX+-9),BC
	JR	L_70
L_68:
;  265	      sprintf(searchName, "%.2s%03u%03u\0",imgID, xSquare, ySquare);//combines the separate parts into one name to search for
	LD	BC,(IX+-9)
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	PEA	IX+-23
	LD	BC,L__31
	PUSH	BC
	PEA	IX+-62
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  266	
;  267	      /*This opens the variable with the name that was just assembled.
;  268	      * It then gets the pointer to that and stores it in a graphics variable
;  269	      */
;  270	      squareSlot = ti_Open(searchName,"r");
	LD	BC,L__32
	PUSH	BC
	PEA	IX+-62
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-2),A
;  271	      //checks if the square exists
;  272	      if (!squareSlot){
	OR	A,A
	JR	NZ,L_65
;  273	        PrintCentered("Square doesn't exist!");
	LD	BC,L__34
	PUSH	BC
	CALL	_PrintCentered
	POP	BC
;  274	        PrintCenteredX(searchName,130);
	LD	BC,130
	PUSH	BC
	PEA	IX+-62
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  275	        while(!os_GetCSC());
L_62:
	CALL	_os_GetCSC
	OR	A,A
	JR	NZ,L_69
	JR	L_62
;  276	        continue;
;  277	      }
L_65:
;  278	      //if the square was detected, display it!
;  279	      //seeks past header
;  280	      ti_Seek(16,SEEK_CUR,squareSlot);
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  281	      //store the original image into srcImg
;  282	      srcImg = (gfx_sprite_t*)ti_GetDataPtr(squareSlot);
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	CALL	_ti_GetDataPtr
	POP	BC
	LD	(IX+-44),HL
;  283	      //resizes it to outputImg size
;  284	      gfx_ScaleSprite(srcImg,outputImg);
	LD	BC,(IX+-12)
	PUSH	BC
	LD	BC,(IX+-44)
	PUSH	BC
	CALL	_gfx_ScaleSprite
	POP	BC
	POP	BC
;  285	      //displays the output image
;  286	      dbg_sprintf(dbgout,"\nxSquare: %d \nnewWidthHeight: %d \nscaleDen: %d",xSquare,newWidthHeight,scaleDen);
;  287	      gfx_ScaledSprite_NoClip(outputImg,(xSquare-1)*(newWidthHeight/scaleDen),ySquare*(newWidthHeight/scaleDen),1,1);
	LD	HL,(IX+-41)
	LD	BC,(IX+-29)
	CALL	__idivu
	LD	DE,HL
	LD	HL,DE
	LD	BC,1
	PUSH	BC
	PUSH	BC
	LD	B,(IX+-9)
	LD	C,L
	MLT	BC
	LD	B,0
	PUSH	BC
	LD	IY,(IX+-6)
	LEA	HL,IY+-1
	LD	BC,DE
	CALL	__imulu
	PUSH	HL
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_gfx_ScaledSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  288	      //cleans up
;  289	      ti_Close(squareSlot);
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
;  290	    }
L_69:
	LD	BC,(IX+-9)
	INC	BC
	LD	(IX+-9),BC
L_70:
	LD	BC,(IX+-15)
	INC	BC
	OR	A,A
	LD	HL,(IX+-9)
	SBC	HL,BC
	JR	C,L_68
	LD	IY,(IX+-6)
	LEA	IY,IY+-1
	LD	(IX+-6),IY
;  291	  }
L_73:
	LD	BC,(IX+-6)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_71
;  292	  free(outputImg);
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_free
	POP	BC
;  293	}
L_76:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _DrawImage ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_gfx_ScaledSprite_NoClip            IMPORT  -----   function
;_gfx_ScaleSprite                    IMPORT  -----   function
;_PrintCentered                      IMPORT  -----   function
;_gfx_SetPalette                     IMPORT  -----   function
;_ti_GetDataPtr                      IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_PrintCenteredX                     IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_gfx_AllocSprite                    IMPORT  -----   function
;_gfx_SetTextScale                   IMPORT  -----   function
;_ti_Close                           IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_ti_Seek                            IMPORT  -----   function
;_gfx_FillScreen                     IMPORT  -----   function
;_ti_Open                            IMPORT  -----   function
;palPtr                              IX-830    768   variable
;searchName                           IX-62      9   variable
;palName                              IX-53      9   variable
;srcImg                               IX-44      3   variable
;newWidthHeight                       IX-41      3   variable
;maxHSquares                          IX-38      3   variable
;scaleNum                             IX-35      3   variable
;maxWSquares                          IX-32      3   variable
;scaleDen                             IX-29      3   variable
;widthSquares                         IX-26      3   variable
;imgID                                IX-23      2   variable
;imgWH                                IX-21      6   variable
;heightSquares                        IX-15      3   variable
;outputImg                            IX-12      3   variable
;ySquare                               IX-9      3   variable
;xSquare                               IX-6      3   variable
;palSlot                               IX-3      1   variable
;squareSlot                            IX-2      1   variable
;database                              IX-1      1   variable
;maxHeight                            IX+12      3   parameter
;maxWidth                              IX+9      3   parameter
;picName                               IX+6      3   parameter


; Stack Frame Size: 845 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__20:
	DB	"r"
	DB	0
L__21:
	DB	"HDPICDB"
	DB	0
L__24:
	DB	"Failed to allocate memory!"
	DB	0
L__26:
	DB	"HP%.2s0000"
	DB	0,0
L__27:
	DB	"r"
	DB	0
L__29:
	DB	"Palette does not exist!"
	DB	0
L__31:
	DB	"%.2s%03u%03u"
	DB	0,0
L__32:
	DB	"r"
	DB	0
L__34:
	DB	"Square doesn't exist!"
	DB	0
	SEGMENT CODE
;  294	
;  295	
;  296	/* This UI keeps the user selection in the middle of the screen. */
;  297	void printNames(uint24_t startName, char *picNames, uint24_t numOfPics){
_printNames:
	LD	HL,-12
	CALL	__frameset
;  298	  uint24_t i, Yoffset=0, y=0, curName=0;
	LD	BC,0
	LD	(IX+-12),BC
	LD	(IX+-6),BC
;  299	
;  300	  //clears old text and sets up for new text
;  301	  gfx_SetTextScale(2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  302	  gfx_SetColor(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  303	  gfx_FillRectangle_NoClip(0,0,140,240);
	LD	BC,240
	PUSH	BC
	LD	BC,140
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  304	  gfx_SetColor(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  305	
;  306	  //re-draws UI lines
;  307	  gfx_HorizLine_NoClip(0,120,6);
	LD	BC,6
	PUSH	BC
	LD	BC,120
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gfx_HorizLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  308	  gfx_HorizLine_NoClip(136,120,5);
	LD	BC,5
	PUSH	BC
	LD	BC,120
	PUSH	BC
	LD	BC,136
	PUSH	BC
	CALL	_gfx_HorizLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  309	  gfx_HorizLine_NoClip(6,110,130);
	LD	BC,130
	PUSH	BC
	LD	BC,110
	PUSH	BC
	LD	BC,6
	PUSH	BC
	CALL	_gfx_HorizLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  310	  gfx_HorizLine_NoClip(6,130,130);
	LD	BC,130
	PUSH	BC
	PUSH	BC
	LD	BC,6
	PUSH	BC
	CALL	_gfx_HorizLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  311	  gfx_VertLine_NoClip(6,110,20);
	LD	BC,20
	PUSH	BC
	LD	BC,110
	PUSH	BC
	LD	BC,6
	PUSH	BC
	CALL	_gfx_VertLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  312	  gfx_VertLine_NoClip(136,110,21);
	LD	BC,21
	PUSH	BC
	LD	BC,110
	PUSH	BC
	LD	BC,136
	PUSH	BC
	CALL	_gfx_VertLine_NoClip
	POP	BC
	POP	BC
	POP	BC
;  313	
;  314	  /*if the selected start name is under 4, that means we need to start drawing
;  315	  * farther down the screen for the text to go in the right spot */
;  316	  if(startName<4){
	LD	HL,(IX+6)
	LD	BC,4
	OR	A,A
	SBC	HL,BC
	JR	NC,L_78
;  317	    Yoffset = 75 - startName * Y_SPACING;
	LD	HL,(IX+6)
;  318	    startName = 0;
	LD	BC,0
	LD	A,25
	CALL	__imul_b
	LD	DE,HL
	LD	HL,75
	OR	A,A
	SBC	HL,DE
	LD	(IX+-12),HL
	LD	(IX+6),BC
;  319	  }else{
	JR	L_79
L_78:
;  320	    startName-=4;
	LD	IY,(IX+6)
	LEA	IY,IY+-4
	LD	(IX+6),IY
;  321	  }
L_79:
;  322	  curName=startName;
	LD	BC,(IX+6)
	LD	(IX+-9),BC
;  323	
;  324	
;  325	  /* draw the text on the screen. Starts displaying the name at element start
;  326	  * then iterates until out of pics or about to draw off the screen */
;  327	  for(i=0;i<numOfPics && y<180;i++){
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_85
L_83:
;  328	    //calculates where the text should be drawn
;  329	    y = i * Y_SPACING + Y_MARGIN + Yoffset;
	LD	HL,(IX+-3)
	LD	A,25
	CALL	__imul_b
	LD	IY,HL
	LEA	HL,IY+38
	LD	BC,(IX+-12)
	ADD	HL,BC
	LD	(IX+-6),HL
;  330	
;  331	    //Prints out the correct name
;  332	    gfx_PrintStringXY(&picNames[curName++*BYTES_PER_IMAGE_NAME],X_MARGIN,y);
	LD	DE,(IX+-9)
	INC	DE
	LD	BC,(IX+-9)
	LD	(IX+-9),DE
	LD	DE,(IX+-6)
	PUSH	DE
	LD	HL,9
	LD	DE,8
	PUSH	DE
	LD	DE,(IX+9)
	CALL	__imulu
	ADD	HL,DE
	PUSH	HL
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  333	    //while(!os_GetCSC());
;  334	
;  335	  }
L_85:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_86
	LD	BC,180
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	JR	C,L_83
L_86:
;  336	  //slows down scrolling speed
;  337	  delay(150);
	LD	BC,150
	PUSH	BC
	CALL	_delay
	POP	BC
;  338	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printNames ***************************
;Name                         Addr/Register   Size   Type
;_delay                              IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;_gfx_VertLine_NoClip                IMPORT  -----   function
;_gfx_HorizLine_NoClip               IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_gfx_SetTextScale                   IMPORT  -----   function
;Yoffset                              IX-12      3   variable
;curName                               IX-9      3   variable
;y                                     IX-6      3   variable
;i                                     IX-3      3   variable
;numOfPics                            IX+12      3   parameter
;picNames                              IX+9      3   parameter
;startName                             IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


;  339	
;  340	
;  341	
;  342	/* Rebuilds the database of images on the calculator*/
;  343	uint24_t rebuildDB(uint8_t p){
_rebuildDB:
	LD	HL,-67
	CALL	__frameset
;  344	  char *var_name, *imgInfo[16], nameBuffer[10];
;  345	  uint8_t *search_pos = NULL;
	LD	BC,0
	LD	(IX+-11),BC
;  346	  uint24_t imagesFound=0;
	LD	(IX+-4),BC
;  347	  char myData[8]="HDPALV1",names[8];
	LEA	DE,IX+-19
;  348	  ti_var_t database = ti_Open("HDPICDB","w"), palette;
	LD	BC,L__43
	PUSH	BC
	LD	BC,L__44
	PUSH	BC
	LD	HL,_0temp88
	LD	BC,8
	LDIR	
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-1),A
;  349	  ti_Write("HDDATV10",8,1,database);//Rewrites the header because w overwrites everything
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	LD	BC,L__45
	PUSH	BC
	CALL	_ti_Write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  350	
;  351	  //resets splash screen for new loading SetLoadingBarProgress
;  352	  SplashScreen();
	CALL	_SplashScreen
;  353	
;  354	  /*
;  355	  * Searches for palettes. This is a lot easier than searching for every single
;  356	  * image square because there's is guarunteed to only be one palette per image.
;  357	  * The palette containts all the useful information such as the image size and
;  358	  * the two letter ID for each appvar. This makes it easy to find every square via a loop.
;  359	  */
;  360	  while((var_name = ti_DetectVar(&search_pos, "HDPALV10", TI_APPVAR_TYPE)) != NULL) {
	JR	L_89
L_90:
;  361	    //sets progress of how many images were found
;  362	    SetLoadingBarProgress(++imagesFound,MAX_IMAGES);
	LD	BC,(IX+-4)
	INC	BC
	LD	(IX+-4),BC
	LD	BC,168
	PUSH	BC
	LD	C,(IX+-4)
	LD	B,0
	PUSH	BC
	CALL	_SetLoadingBarProgress
	POP	BC
	POP	BC
;  363	    //finds the name, letter ID, and size of entire image this palette belongs to.
;  364	    palette = ti_Open(var_name,"r");
	LD	BC,L__46
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-5),A
;  365	    //seeks past useless info
;  366	    ti_Seek(8,SEEK_CUR,palette);
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  367	    ti_Seek(16,SEEK_CUR,database);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16
	PUSH	BC
	CALL	_ti_Seek
	POP	BC
	POP	BC
	POP	BC
;  368	    //reads the important info (16 bytes)
;  369	    ti_Read(&imgInfo,16,1,palette);
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16
	PUSH	BC
	PEA	IX+-67
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  370	    //Writes the info to the database
;  371	    ti_Write(imgInfo,16,1,database);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,16
	PUSH	BC
	PEA	IX+-67
	CALL	_ti_Write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  372	    //closes palette for next iteration
;  373	    ti_Close(palette);
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
;  374	  }
L_89:
	LD	BC,21
	PUSH	BC
	LD	BC,L__47
	PUSH	BC
	PEA	IX+-11
	CALL	_ti_DetectVar
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-8),HL
	CALL	__icmpzero
	JR	NZ,L_90
;  375	  //closes the database
;  376	  ti_Close(database);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_ti_Close
	POP	BC
;  377	  gfx_End();
	CALL	_gfx_End
;  378	  ti_SetArchiveStatus(true,database);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_ti_SetArchiveStatus
	POP	BC
	POP	BC
;  379	  gfx_Begin();
	CALL	_gfx_Begin
;  380	  SplashScreen();
	CALL	_SplashScreen
;  381	  gfx_SetTextXY(100,195);
	LD	BC,195
	PUSH	BC
	LD	BC,100
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  382	  gfx_PrintUInt(imagesFound,3);
	LD	BC,3
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_gfx_PrintUInt
	POP	BC
	POP	BC
;  383	  if (imagesFound==0){
	LD	HL,(IX+-4)
	CALL	__icmpzero
	JR	NZ,L_93
;  384	    noImagesFound();
	CALL	_noImagesFound
;  385	  }
L_93:
;  386	  SetLoadingBarProgress(++p,TASKS_TO_FINISH);
	INC	(IX+6)
	LD	BC,2
	PUSH	BC
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	CALL	_SetLoadingBarProgress
	POP	BC
	POP	BC
;  387	
;  388	
;  389	
;  390	  return imagesFound;
	LD	HL,(IX+-4)
;  391	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _rebuildDB ***************************
;Name                         Addr/Register   Size   Type
;_noImagesFound                      IMPORT  -----   function
;_gfx_PrintUInt                      IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_ti_SetArchiveStatus                IMPORT  -----   function
;_gfx_End                            IMPORT  -----   function
;_ti_DetectVar                       IMPORT  -----   function
;_ti_Close                           IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_ti_Seek                            IMPORT  -----   function
;_SetLoadingBarProgress              IMPORT  -----   function
;_SplashScreen                       IMPORT  -----   function
;_ti_Write                           IMPORT  -----   function
;_ti_Open                            IMPORT  -----   function
;_0temp88                            STATIC      8   variable
;imgInfo                              IX-67     48   variable
;myData                               IX-19      8   variable
;search_pos                           IX-11      3   variable
;var_name                              IX-8      3   variable
;palette                               IX-5      1   variable
;imagesFound                           IX-4      3   variable
;database                              IX-1      1   variable
;p                                     IX+6      1   parameter


; Stack Frame Size: 76 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__43:
	DB	"w"
	DB	0
L__44:
	DB	"HDPICDB"
	DB	0
L__45:
	DB	"HDDATV10"
	DB	0
L__46:
	DB	"r"
	DB	0
L__47:
	DB	"HDPALV10"
	DB	0
	SEGMENT TEXT
_0temp88:
	DB	72
	DB	68
	DB	80
	DB	65
	DB	76
	DB	86
	DB	49
	DB	0
	SEGMENT CODE
;  392	
;  393	void noImagesFound(){
_noImagesFound:
;  394	  gfx_SetTextFGColor(192);
	LD	BC,192
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  395	  PrintCenteredX("No Pictures Detected!",1);
	LD	BC,1
	PUSH	BC
	LD	BC,L__51
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  396	  gfx_SetTextFGColor(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  397	  PrintCenteredX("Convert some images and send them to your",11);
	LD	BC,11
	PUSH	BC
	LD	BC,L__52
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  398	  PrintCenteredX("calculator using the HDpic converter!",21);
	LD	BC,21
	PUSH	BC
	LD	BC,L__53
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  399	  PrintCenteredX("Tutorial:  https://youtu.be/s1-g8oSueQg",31);
	LD	BC,31
	PUSH	BC
	LD	BC,L__54
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  400	  PrintCenteredX("Press any key to quit",41);
	LD	BC,41
	PUSH	BC
	LD	BC,L__55
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  401	  return;
;  402	}
	RET	


;**************************** _noImagesFound ***************************
;Name                         Addr/Register   Size   Type
;_PrintCenteredX                     IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__51:
	DB	"No Pictures Detected!"
	DB	0
L__52:
	DB	"Convert some images and send them to your"
	DB	0
L__53:
	DB	"calculator using the HDpic converter!"
	DB	0
L__54:
	DB	"Tutorial:  https://youtu.be/s1-g8oSueQg"
	DB	0
L__55:
	DB	"Press any key to quit"
	DB	0
	SEGMENT CODE
;  403	
;  404	//checks if the database is already created. If not, it creates it.
;  405	uint8_t databaseReady(){
_databaseReady:
	LD	HL,-27
	CALL	__frameset
;  406	  char *var_name;
;  407	  uint8_t *search_pos = NULL, exists=0, ready = 0;
	LD	BC,0
	LD	(IX+-6),BC
	LD	(IX+-3),0
;  408	  ti_var_t myAppVar;
;  409	  char myData[9]="HDDATV10"; //remember have one more space than text you're saving for null termiation
	LEA	DE,IX+-18
	LD	HL,_1temp96
	LD	BC,9
	LDIR	
;  410	  char compare[9]="HDDATV10";
	LEA	DE,IX+-27
	LD	HL,_2temp97
	LD	BC,9
	LDIR	
;  411	  //tries to find database using known header
;  412	  while((var_name = ti_DetectVar(&search_pos, myData, TI_APPVAR_TYPE)) != NULL) {
	JR	L_98
L_99:
;  413	    exists=1;
	LD	(IX+-3),1
;  414	  }
L_98:
	LD	BC,21
	PUSH	BC
	PEA	IX+-18
	PEA	IX+-6
	CALL	_ti_DetectVar
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-9),HL
	CALL	__icmpzero
	JR	NZ,L_99
;  415	  //if file already exists, simply return
;  416	  if (exists == 1)
	LD	A,(IX+-3)
	CP	A,1
	JR	NZ,L_111
;  417	  ready = 2;
	LD	(IX+-1),2
;  418	  else{
	JR	L_113
L_111:
;  419	    //if file doesn't already exist, create it.
;  420	    //creates the database appvar and writes the header. Checks if wrote successfuly
;  421	    myAppVar=ti_Open("HDPICDB", "w");
	LD	BC,L__59
	PUSH	BC
	LD	BC,L__60
	PUSH	BC
	CALL	_ti_Open
	POP	BC
	POP	BC
	LD	(IX+-2),A
;  422	    if(!myAppVar)
;  423	    ready = 3;
;  424	    if(ti_Write(&myData,8,1,myAppVar)!=1)
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	PEA	IX+-18
	CALL	_ti_Write
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  425	    ready = 4;
;  426	    if (ti_Rewind(myAppVar) == EOF)
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	CALL	_ti_Rewind
	POP	BC
;  427	    ready = 5;
;  428	    if (ti_Read(&myData,8, 1, myAppVar) != 1)
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,8
	PUSH	BC
	PEA	IX+-18
	CALL	_ti_Read
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  429	    ready = 6;
;  430	    if (strcmp(myData,compare)!=0)
	PEA	IX+-27
	PEA	IX+-18
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_108
;  431	    ready = 7;
	LD	(IX+-1),7
;  432	    else{
	JR	L_113
L_108:
;  433	      ready = 1;
	LD	(IX+-1),1
;  434	    }
;  435	  }
L_113:
;  436	  ti_CloseAll();
	CALL	_ti_CloseAll
;  437	
;  438	  //checks what happened
;  439	  if(ready==1){
	LD	A,(IX+-1)
	CP	A,1
	JR	NZ,L_117
;  440	    gfx_SetTextFGColor(195);
	LD	BC,195
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  441	    PrintCenteredX("created",180);
	LD	BC,180
	PUSH	BC
	LD	BC,L__67
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  442	    return 1;
	LD	A,1
	JR	L_118
;  443	  }else if(ready==2){
L_117:
	LD	A,(IX+-1)
	CP	A,2
	JR	NZ,L_115
;  444	    gfx_SetTextFGColor(004);
	LD	BC,4
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  445	    PrintCenteredX("exists",180);
	LD	BC,180
	PUSH	BC
	LD	BC,L__69
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  446	    return 2;
	LD	A,2
	JR	L_118
;  447	  }else{
L_115:
;  448	    gfx_SetTextFGColor(224);
	LD	BC,224
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  449	    PrintCenteredX("failure",180);
	LD	BC,180
	PUSH	BC
	LD	BC,L__70
	PUSH	BC
	CALL	_PrintCenteredX
	POP	BC
	POP	BC
;  450	    gfx_SetTextXY(120,190);
	LD	BC,190
	PUSH	BC
	LD	BC,120
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  451	    gfx_PrintUInt(ready,1);
	LD	BC,1
	PUSH	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_gfx_PrintUInt
	POP	BC
	POP	BC
;  452	    return 0;
	XOR	A,A
;  453	  }
;  454	
;  455	
;  456	}
L_118:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _databaseReady ***************************
;Name                         Addr/Register   Size   Type
;_gfx_PrintUInt                      IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_PrintCenteredX                     IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_ti_CloseAll                        IMPORT  -----   function
;_strcmp                             IMPORT  -----   function
;_ti_Read                            IMPORT  -----   function
;_ti_Rewind                          IMPORT  -----   function
;_ti_Write                           IMPORT  -----   function
;_ti_Open                            IMPORT  -----   function
;_ti_DetectVar                       IMPORT  -----   function
;_2temp97                            STATIC      9   variable
;_1temp96                            STATIC      9   variable
;compare                              IX-27      9   variable
;myData                               IX-18      9   variable
;var_name                              IX-9      3   variable
;search_pos                            IX-6      3   variable
;exists                                IX-3      1   variable
;myAppVar                              IX-2      1   variable
;ready                                 IX-1      1   variable


; Stack Frame Size: 33 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__59:
	DB	"w"
	DB	0
L__60:
	DB	"HDPICDB"
	DB	0
L__67:
	DB	"created"
	DB	0
L__69:
	DB	"exists"
	DB	0
L__70:
	DB	"failure"
	DB	0
	SEGMENT TEXT
_1temp96:
	DB	72
	DB	68
	DB	68
	DB	65
	DB	84
	DB	86
	DB	49
	DB	48
	DB	0
_2temp97:
	DB	72
	DB	68
	DB	68
	DB	65
	DB	84
	DB	86
	DB	49
	DB	48
	DB	0
	SEGMENT CODE
;  457	
;  458	//makes a loading bar and fills it in depending on progress made (p) / tasks left (t)
;  459	void SetLoadingBarProgress(uint8_t p, uint8_t t){
_SetLoadingBarProgress:
	LD	HL,-4
	CALL	__frameset
;  460	  p=((double)p/(double)t)*200.0;
	UEXT	HL
	LD	L,(IX+6)
	LD	A,H
	LD	BC,HL
	CALL	__ultof
	LD	(IX+-1),A
	UEXT	HL
	LD	L,(IX+9)
	LD	A,H
	LD	(IX+-4),BC
	LD	BC,HL
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fdiv
	LD	HL,4718592
	LD	E,67
	CALL	__fmul
	CALL	__ftol
	LD	(IX+6),C
;  461	  //ensures loading bar doesn't go past max point
;  462	  if (p>200)
	LD	A,200
	CP	A,(IX+6)
	JR	NC,L_120
;  463	  p=200;
	LD	(IX+6),200
L_120:
;  464	
;  465	  gfx_SetColor(128);
	LD	BC,128
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  466	  gfx_FillRectangle_NoClip(60,153,(uint8_t)p,7);
	LD	BC,7
	PUSH	BC
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,153
	PUSH	BC
	LD	BC,60
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  467	
;  468	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _SetLoadingBarProgress ***************************
;Name                         Addr/Register   Size   Type
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;t                                     IX+9      1   parameter
;p                                     IX+6      1   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;  469	
;  470	//creates a simple splash screen when program starts
;  471	void SplashScreen(){
_SplashScreen:
;  472	  //sets color to grey
;  473	  gfx_SetColor(181);
	LD	BC,181
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  474	  gfx_FillRectangle_NoClip(60,80,LCD_WIDTH-120,LCD_HEIGHT-160);
	LD	BC,80
	PUSH	BC
	LD	BC,200
	PUSH	BC
	LD	BC,80
	PUSH	BC
	LD	BC,60
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  475	  /* Print title screen */
;  476	  PrintCentered("HD Picture Viewer");
	LD	BC,L__74
	PUSH	BC
	CALL	_PrintCentered
	POP	BC
;  477	}
	RET	


;**************************** _SplashScreen ***************************
;Name                         Addr/Register   Size   Type
;_PrintCentered                      IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__74:
	DB	"HD Picture Viewer"
	DB	0
	SEGMENT CODE
;  478	
;  479	/* Prints a screen centered string */
;  480	void PrintCentered(const char *str)
;  481	{
_PrintCentered:
	CALL	__frameset0
;  482	  gfx_PrintStringXY(str,(LCD_WIDTH - gfx_GetStringWidth(str)) / 2, (LCD_HEIGHT - 8) / 2);
	LD	BC,116
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_GetStringWidth
	POP	BC
	LD	BC,HL
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	LD	A,1
	CALL	__ishru_b
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  483	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _PrintCentered ***************************
;Name                         Addr/Register   Size   Type
;_gfx_GetStringWidth                 IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;str                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  484	/* Prints a X centered string */
;  485	void PrintCenteredX(const char *str, uint8_t y)
;  486	{
_PrintCenteredX:
	CALL	__frameset0
;  487	  gfx_PrintStringXY(str, (LCD_WIDTH - gfx_GetStringWidth(str)) / 2, y);
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_GetStringWidth
	POP	BC
	LD	BC,HL
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	LD	A,1
	CALL	__ishru_b
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  488	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _PrintCenteredX ***************************
;Name                         Addr/Register   Size   Type
;_gfx_GetStringWidth                 IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;y                                     IX+9      1   parameter
;str                                   IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  489	/* Prints a Y centered string */
;  490	void PrintCenteredY(const char *str, uint8_t x)
;  491	{
_PrintCenteredY:
	CALL	__frameset0
;  492	  gfx_PrintStringXY(str, x, (LCD_HEIGHT - 8) / 2);
	LD	BC,116
	PUSH	BC
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  493	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _PrintCenteredY ***************************
;Name                         Addr/Register   Size   Type
;_gfx_PrintStringXY                  IMPORT  -----   function
;x                                     IX+9      1   parameter
;str                                   IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  494	
;  495	
;  496	/* Draw text on the homescreen at the given X/Y location */
;  497	void printText(int8_t xpos, int8_t ypos, const char *text) {
_printText:
	CALL	__frameset0
;  498	  os_SetCursorPos(ypos, xpos);
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	CALL	_os_SetCursorPos
	POP	BC
	POP	BC
;  499	  os_PutStrFull(text);
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_os_PutStrFull
	POP	BC
;  500	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printText ***************************
;Name                         Addr/Register   Size   Type
;_os_PutStrFull                      IMPORT  -----   function
;_os_SetCursorPos                    IMPORT  -----   function
;text                                 IX+12      3   parameter
;ypos                                  IX+9      1   parameter
;xpos                                  IX+6      1   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


	XREF _strcmp:ROM
	XREF _sprintf:ROM
	XREF _ti_GetDataPtr:ROM
	XREF _ti_SetArchiveStatus:ROM
	XREF _ti_Rewind:ROM
	XREF _ti_Seek:ROM
	XREF _ti_Read:ROM
	XREF _ti_Write:ROM
	XREF _ti_DetectVar:ROM
	XREF _ti_Close:ROM
	XREF _ti_Open:ROM
	XREF _ti_CloseAll:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_GetStringWidth:ROM
	XREF _gfx_ScaleSprite:ROM
	XREF _gfx_ScaledSprite_NoClip:ROM
	XREF _gfx_SetTextBGColor:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintStringXY:ROM
	XREF _gfx_PrintUInt:ROM
	XREF _gfx_SetTextScale:ROM
	XREF _gfx_FillRectangle_NoClip:ROM
	XREF _gfx_VertLine_NoClip:ROM
	XREF _gfx_VertLine:ROM
	XREF _gfx_HorizLine_NoClip:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _os_GetCSC:ROM
	XREF _os_PutStrFull:ROM
	XREF _os_SetCursorPos:ROM
	XREF _delay:ROM
	XREF __idivu:ROM
	XREF __imulu:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __ftol:ROM
	XREF __ultof:ROM
	XREF __ildix:ROM
	XREF __istix:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __icmpzero:ROM
	XREF __imul_b:ROM
	XREF __ishru_b:ROM
	XDEF _printText
	XDEF _PrintCenteredY
	XDEF _PrintCenteredX
	XDEF _PrintCentered
	XDEF _SplashScreen
	XDEF _SetLoadingBarProgress
	XDEF _databaseReady
	XDEF _noImagesFound
	XDEF _rebuildDB
	XDEF _printNames
	XDEF _DrawImage
	XDEF _DisplayHomeScreen
	XDEF _main
	END
